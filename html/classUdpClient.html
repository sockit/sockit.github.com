<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SockIt: UdpClient Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SockIt</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<h1>UdpClient Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="UdpClient" --><!-- doxytag: inherits="Udp,Client" -->
<p><code>#include &lt;<a class="el" href="UdpClient_8h_source.html">UdpClient.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for UdpClient:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classUdpClient.png" usemap="#UdpClient_map" alt=""/>
  <map id="UdpClient_map" name="UdpClient_map">
<area href="classUdp.html" alt="Udp" shape="rect" coords="0,56,95,80"/>
<area href="classClient.html" alt="Client" shape="rect" coords="105,56,200,80"/>
<area href="classNetworkObject.html" alt="NetworkObject" shape="rect" coords="105,0,200,24"/>
</map>
 </div></div>

<p><a href="classUdpClient-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUdpClient.html#a3939a516b0c78c572bb6318be26039c8">UdpClient</a> (const string &amp;<a class="el" href="classUdp.html#a798fd48815d9d97045e8e6a3a290d301">host</a>, int <a class="el" href="classUdp.html#af69ea781b31a1fa62e5d3012b6288dc8">port</a>, boost::asio::io_service &amp;<a class="el" href="classUdp.html#a7e143116ab3a0f478c8461ca04af782b">io_service</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUdpClient.html#a3a44547ebe0cbc3b85e0163b32767338">UdpClient</a> (const string &amp;<a class="el" href="classUdp.html#a798fd48815d9d97045e8e6a3a290d301">host</a>, int <a class="el" href="classUdp.html#af69ea781b31a1fa62e5d3012b6288dc8">port</a>, boost::asio::io_service &amp;<a class="el" href="classUdp.html#a7e143116ab3a0f478c8461ca04af782b">io_service</a>, map&lt; string, string &gt; options)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUdpClient.html#a9e69046802da8ea9e0bf3da874c49e47">~UdpClient</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUdpClient.html#a86e50f32bbb7aaf657ea5cc91cbc99d2">send</a> (const string &amp;data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUdpClient.html#ad55f42a3c5cb3698b49975c8a065079e">send_bytes</a> (const vector&lt; <a class="el" href="Event_8h.html#ae0aa21f6bcb621fe36c2c962aa0452fe">byte</a> &gt; &amp;bytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUdpClient.html#a64b6b51f6a2316f7235381409f9cc327">shutdown</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUdpClient.html#aaa19f0f767306e0e974782dd700c5c49">get_port</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUdpClient.html#ac18bd8d30497c82dfe1a63a464d01e00">get_host</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUdpClient.html#a4c1f1672598ea18294f2486e071e0985">init_socket</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUdpClient.html#ae62b9e08cc550a47bbedca2e4556ebcc">fire_error_event</a> (const string &amp;message)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUdpClient.html#acce4181d7ce20a812fffed395486a1bd">fire_data_event</a> (const string data, boost::shared_ptr&lt; udp::socket &gt; <a class="el" href="classUdpClient.html#a5e929af056033e7b1fd3f72ad2bd1849">socket</a>, boost::shared_ptr&lt; udp::endpoint &gt; endpoint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUdpClient.html#a48cc5f9ce547f5b0505fb8395ac93d32">close</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUdpClient.html#a2694066d9e432d68eca656f00152278d">UdpClient</a> (const <a class="el" href="classUdpClient.html">UdpClient</a> &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUdpClient.html#ae62759a7050f171fe12413ec658bb38b">listen</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUdpClient.html#a16e67afc411590eb1602fc02e3395599">resolve_handler</a> (const boost::system::error_code &amp;err, udp::resolver::iterator endpoint_iterator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUdpClient.html#a755db78b027af8161b0b79563c857f2f">flush</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; udp::resolver &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUdpClient.html#a1ea233a699d5d1955bb3fa4bfca2ee2f">resolver</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; udp::socket &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUdpClient.html#a5e929af056033e7b1fd3f72ad2bd1849">socket</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boost::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUdpClient.html#aa978126795bc551151f6442ba8421fc9">queue_mtx</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::queue&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUdpClient.html#a8843ba58204e08e3250b483d459b3416">msgs_not_sent</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUdpClient.html#a342b58425b4ccaf7de2a3ad8dcbc4df8">resolved_endpoint</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock">
<p>Definition at line <a class="el" href="UdpClient_8h_source.html#l00022">22</a> of file <a class="el" href="UdpClient_8h_source.html">UdpClient.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a3939a516b0c78c572bb6318be26039c8"></a><!-- doxytag: member="UdpClient::UdpClient" ref="a3939a516b0c78c572bb6318be26039c8" args="(const string &amp;host, int port, boost::asio::io_service &amp;io_service)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UdpClient::UdpClient </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::asio::io_service &amp;&#160;</td>
          <td class="paramname"><em>io_service</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronously resolves the host and port number after creation. The client will not be able to send messages until after the resolve handler has run to completion.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>The host to connect to </td></tr>
    <tr><td class="paramname">port</td><td>The port the host is listening on </td></tr>
    <tr><td class="paramname">io_service</td><td>The I/O service to be used for asynchronous I/O requests </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="UdpClient_8cpp_source.html#l00016">16</a> of file <a class="el" href="UdpClient_8cpp_source.html">UdpClient.cpp</a>.</p>

<p>References <a class="el" href="Logger_8h_source.html#l00071">Logger::error()</a>, <a class="el" href="Udp_8h_source.html#l00213">Udp::failed</a>, <a class="el" href="UdpClient_8h_source.html#l00144">resolver</a>, and <a class="el" href="UdpClient_8h_source.html#l00149">socket</a>.</p>
<div class="fragment"><pre class="fragment">                                                                                  :
    <a class="code" href="classUdp.html#a9a7578235269c76bf6d810b7ac1eb268">Udp</a>(<a class="code" href="classUdp.html#a798fd48815d9d97045e8e6a3a290d301">host</a>, <a class="code" href="classUdp.html#af69ea781b31a1fa62e5d3012b6288dc8">port</a>, ioService), <a class="code" href="classUdpClient.html#a1ea233a699d5d1955bb3fa4bfca2ee2f">resolver</a>(<span class="keyword">new</span> udp::resolver(<a class="code" href="classUdp.html#a7e143116ab3a0f478c8461ca04af782b">io_service</a>)), <a class="code" href="classUdpClient.html#a5e929af056033e7b1fd3f72ad2bd1849">socket</a>(<span class="keyword">new</span> udp::socket(<a class="code" href="classUdp.html#a7e143116ab3a0f478c8461ca04af782b">io_service</a>)), <a class="code" href="classUdpClient.html#a342b58425b4ccaf7de2a3ad8dcbc4df8">resolved_endpoint</a>(<span class="keyword">false</span>)
{
    <span class="comment">// Check that the connection and resolver are valid, and fail gracefully if they are not</span>
    <span class="keywordflow">if</span> (!<a class="code" href="classUdpClient.html#a1ea233a699d5d1955bb3fa4bfca2ee2f">resolver</a>.get() || !<a class="code" href="classUdpClient.html#a5e929af056033e7b1fd3f72ad2bd1849">socket</a>.get())
    {
        <a class="code" href="classUdp.html#a91a6ea6959febc662830e818b89ed884">failed</a> = <span class="keyword">true</span>;
        <span class="keywordtype">string</span> message(<span class="stringliteral">&quot;Failed to initialize UDP client, failed to initialize properly&quot;</span>);
        <a class="code" href="classLogger.html#adb709be72ac3e448f2af97b9cafaef2f">Logger::error</a>(message, <a class="code" href="classUdp.html#af69ea781b31a1fa62e5d3012b6288dc8">port</a>, <a class="code" href="classUdp.html#a798fd48815d9d97045e8e6a3a290d301">host</a>);
        fire_error(message);
        <span class="keywordflow">return</span>;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3a44547ebe0cbc3b85e0163b32767338"></a><!-- doxytag: member="UdpClient::UdpClient" ref="a3a44547ebe0cbc3b85e0163b32767338" args="(const string &amp;host, int port, boost::asio::io_service &amp;io_service, map&lt; string, string &gt; options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UdpClient::UdpClient </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::asio::io_service &amp;&#160;</td>
          <td class="paramname"><em>io_service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; string, string &gt;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronously resolves the host and port number after creation. The client will not be able to send messages until after the resolve handler has run to completion.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>The host to connect to </td></tr>
    <tr><td class="paramname">port</td><td>The port the host is listening on </td></tr>
    <tr><td class="paramname">io_service</td><td>The I/O service to be used for asynchronous I/O requests </td></tr>
    <tr><td class="paramname">options</td><td>A map of additional options to configure this UDP client </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="UdpClient_8cpp_source.html#l00030">30</a> of file <a class="el" href="UdpClient_8cpp_source.html">UdpClient.cpp</a>.</p>

<p>References <a class="el" href="Logger_8h_source.html#l00071">Logger::error()</a>, <a class="el" href="Udp_8h_source.html#l00213">Udp::failed</a>, <a class="el" href="Udp_8cpp_source.html#l00107">Udp::parse_args()</a>, <a class="el" href="UdpClient_8h_source.html#l00144">resolver</a>, and <a class="el" href="UdpClient_8h_source.html#l00149">socket</a>.</p>
<div class="fragment"><pre class="fragment">                                                                                                               :
    <a class="code" href="classUdp.html#a9a7578235269c76bf6d810b7ac1eb268">Udp</a>(<a class="code" href="classUdp.html#a798fd48815d9d97045e8e6a3a290d301">host</a>, <a class="code" href="classUdp.html#af69ea781b31a1fa62e5d3012b6288dc8">port</a>, ioService), <a class="code" href="classUdpClient.html#a1ea233a699d5d1955bb3fa4bfca2ee2f">resolver</a>(<span class="keyword">new</span> udp::resolver(<a class="code" href="classUdp.html#a7e143116ab3a0f478c8461ca04af782b">io_service</a>)), <a class="code" href="classUdpClient.html#a5e929af056033e7b1fd3f72ad2bd1849">socket</a>(<span class="keyword">new</span> udp::socket(<a class="code" href="classUdp.html#a7e143116ab3a0f478c8461ca04af782b">io_service</a>)), <a class="code" href="classUdpClient.html#a342b58425b4ccaf7de2a3ad8dcbc4df8">resolved_endpoint</a>(<span class="keyword">false</span>)
{
    <span class="comment">// Check that the connection and resolver are valid, and fail gracefully if they are not</span>
    <span class="keywordflow">if</span> (!<a class="code" href="classUdpClient.html#a1ea233a699d5d1955bb3fa4bfca2ee2f">resolver</a>.get() || !<a class="code" href="classUdpClient.html#a5e929af056033e7b1fd3f72ad2bd1849">socket</a>.get())
    {
        <a class="code" href="classUdp.html#a91a6ea6959febc662830e818b89ed884">failed</a> = <span class="keyword">true</span>;
        <span class="keywordtype">string</span> message(<span class="stringliteral">&quot;Failed to initialize UDP client, failed to initialize properly&quot;</span>);
        <a class="code" href="classLogger.html#adb709be72ac3e448f2af97b9cafaef2f">Logger::error</a>(message, <a class="code" href="classUdp.html#af69ea781b31a1fa62e5d3012b6288dc8">port</a>, <a class="code" href="classUdp.html#a798fd48815d9d97045e8e6a3a290d301">host</a>);
        fire_error(message);
        <span class="keywordflow">return</span>;
    }

    <a class="code" href="classUdp.html#a19fe0f8b3b2f75cee6ae2841b032c64e">parse_args</a>(options);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9e69046802da8ea9e0bf3da874c49e47"></a><!-- doxytag: member="UdpClient::~UdpClient" ref="a9e69046802da8ea9e0bf3da874c49e47" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UdpClient::~UdpClient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deconstructs a UDP client, immediately calling <code>close</code> to shutdown this client's socket and stop listening for responses. </p>

<p>Definition at line <a class="el" href="UdpClient_8cpp_source.html#l00092">92</a> of file <a class="el" href="UdpClient_8cpp_source.html">UdpClient.cpp</a>.</p>

<p>References <a class="el" href="UdpClient_8cpp_source.html#l00097">close()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="classUdpClient.html#a48cc5f9ce547f5b0505fb8395ac93d32">close</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2694066d9e432d68eca656f00152278d"></a><!-- doxytag: member="UdpClient::UdpClient" ref="a2694066d9e432d68eca656f00152278d" args="(const UdpClient &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UdpClient::UdpClient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUdpClient.html">UdpClient</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disallows copying a UDP client </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a48cc5f9ce547f5b0505fb8395ac93d32"></a><!-- doxytag: member="UdpClient::close" ref="a48cc5f9ce547f5b0505fb8395ac93d32" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UdpClient::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Immediately cancels any pending operations and closes this client's socket. </p>

<p>Implements <a class="el" href="classUdp.html#a035ec772c3af57eba9d69cf3ba9dcdda">Udp</a>.</p>

<p>Definition at line <a class="el" href="UdpClient_8cpp_source.html#l00097">97</a> of file <a class="el" href="UdpClient_8cpp_source.html">UdpClient.cpp</a>.</p>

<p>References <a class="el" href="Udp_8h_source.html#l00183">Udp::should_close</a>, and <a class="el" href="UdpClient_8h_source.html#l00149">socket</a>.</p>

<p>Referenced by <a class="el" href="UdpClient_8cpp_source.html#l00107">shutdown()</a>, and <a class="el" href="UdpClient_8cpp_source.html#l00092">~UdpClient()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="classUdp.html#a01a27e2a1b252f39cefd61eb81a18220">should_close</a> = <span class="keyword">true</span>;

    <span class="keywordflow">if</span> (<a class="code" href="classUdpClient.html#a5e929af056033e7b1fd3f72ad2bd1849">socket</a>-&gt;is_open())
    {
        <a class="code" href="classUdpClient.html#a5e929af056033e7b1fd3f72ad2bd1849">socket</a>-&gt;close();
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="acce4181d7ce20a812fffed395486a1bd"></a><!-- doxytag: member="UdpClient::fire_data_event" ref="acce4181d7ce20a812fffed395486a1bd" args="(const string data, boost::shared_ptr&lt; udp::socket &gt; socket, boost::shared_ptr&lt; udp::endpoint &gt; endpoint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UdpClient::fire_data_event </td>
          <td>(</td>
          <td class="paramtype">const string&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; udp::socket &gt;&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; udp::endpoint &gt;&#160;</td>
          <td class="paramname"><em>endpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Helper to fire data event to javascript.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data received </td></tr>
    <tr><td class="paramname">socket</td><td>The socket on which to reply to this data </td></tr>
    <tr><td class="paramname">endpoint</td><td>The connected endpoint to the remote host </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classUdp.html#a08e6e588781ce1e7a4d643b97d63dc5c">Udp</a>.</p>

<p>Definition at line <a class="el" href="UdpClient_8cpp_source.html#l00281">281</a> of file <a class="el" href="UdpClient_8cpp_source.html">UdpClient.cpp</a>.</p>

<p>References <a class="el" href="Udp_8h_source.html#l00183">Udp::should_close</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (<a class="code" href="classUdp.html#a01a27e2a1b252f39cefd61eb81a18220">should_close</a>)
        <span class="keywordflow">return</span>;

    fire_data(boost::make_shared&lt;UdpEvent&gt;(<span class="keyword">this</span>, <a class="code" href="classUdpClient.html#a5e929af056033e7b1fd3f72ad2bd1849">socket</a>, endpoint, data));
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae62b9e08cc550a47bbedca2e4556ebcc"></a><!-- doxytag: member="UdpClient::fire_error_event" ref="ae62b9e08cc550a47bbedca2e4556ebcc" args="(const string &amp;message)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UdpClient::fire_error_event </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Helper to fire an error event to javascript.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The error message </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classUdp.html#a9b79c3603ee9196623aa93b505bda1f6">Udp</a>.</p>

<p>Definition at line <a class="el" href="UdpClient_8cpp_source.html#l00273">273</a> of file <a class="el" href="UdpClient_8cpp_source.html">UdpClient.cpp</a>.</p>

<p>References <a class="el" href="Udp_8h_source.html#l00183">Udp::should_close</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (<a class="code" href="classUdp.html#a01a27e2a1b252f39cefd61eb81a18220">should_close</a>)
        <span class="keywordflow">return</span>;

    fire_error(message);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a755db78b027af8161b0b79563c857f2f"></a><!-- doxytag: member="UdpClient::flush" ref="a755db78b027af8161b0b79563c857f2f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UdpClient::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Flush all pending messages. </p>

<p>Definition at line <a class="el" href="UdpClient_8cpp_source.html#l00238">238</a> of file <a class="el" href="UdpClient_8cpp_source.html">UdpClient.cpp</a>.</p>

<p>References <a class="el" href="UdpClient_8h_source.html#l00159">msgs_not_sent</a>, <a class="el" href="UdpClient_8h_source.html#l00154">queue_mtx</a>, and <a class="el" href="UdpClient_8cpp_source.html#l00137">send()</a>.</p>

<p>Referenced by <a class="el" href="UdpClient_8cpp_source.html#l00200">resolve_handler()</a>, and <a class="el" href="UdpClient_8cpp_source.html#l00137">send()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="classUdpClient.html#aa978126795bc551151f6442ba8421fc9">queue_mtx</a>.lock();

    <span class="keywordflow">while</span> (!<a class="code" href="classUdpClient.html#a8843ba58204e08e3250b483d459b3416">msgs_not_sent</a>.empty())
    {
        <span class="keywordtype">string</span> msg = <a class="code" href="classUdpClient.html#a8843ba58204e08e3250b483d459b3416">msgs_not_sent</a>.front();
        <a class="code" href="classUdpClient.html#a8843ba58204e08e3250b483d459b3416">msgs_not_sent</a>.pop();
        <a class="code" href="classUdpClient.html#aa978126795bc551151f6442ba8421fc9">queue_mtx</a>.unlock();
        <a class="code" href="classUdpClient.html#a86e50f32bbb7aaf657ea5cc91cbc99d2">send</a>(msg);
        <a class="code" href="classUdpClient.html#aa978126795bc551151f6442ba8421fc9">queue_mtx</a>.lock();
    }

    <a class="code" href="classUdpClient.html#aa978126795bc551151f6442ba8421fc9">queue_mtx</a>.unlock();
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac18bd8d30497c82dfe1a63a464d01e00"></a><!-- doxytag: member="UdpClient::get_host" ref="ac18bd8d30497c82dfe1a63a464d01e00" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string UdpClient::get_host </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the host to which this client connects </p>

<p>Implements <a class="el" href="classClient.html#a01e5ea1bae012b2a46e8abd6b0bab704">Client</a>.</p>

<p>Definition at line <a class="el" href="UdpClient_8cpp_source.html#l00263">263</a> of file <a class="el" href="UdpClient_8cpp_source.html">UdpClient.cpp</a>.</p>

<p>References <a class="el" href="Udp_8h_source.html#l00204">Udp::host</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> <a class="code" href="classUdp.html#a798fd48815d9d97045e8e6a3a290d301">host</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aaa19f0f767306e0e974782dd700c5c49"></a><!-- doxytag: member="UdpClient::get_port" ref="aaa19f0f767306e0e974782dd700c5c49" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int UdpClient::get_port </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the port of the remote host on which this client connects </p>

<p>Implements <a class="el" href="classClient.html#ac9e4f13eef6b9a776b2bb6cca9d4f78b">Client</a>.</p>

<p>Definition at line <a class="el" href="UdpClient_8cpp_source.html#l00268">268</a> of file <a class="el" href="UdpClient_8cpp_source.html">UdpClient.cpp</a>.</p>

<p>References <a class="el" href="Udp_8h_source.html#l00207">Udp::port</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> <a class="code" href="classUdp.html#af69ea781b31a1fa62e5d3012b6288dc8">port</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4c1f1672598ea18294f2486e071e0985"></a><!-- doxytag: member="UdpClient::init_socket" ref="a4c1f1672598ea18294f2486e071e0985" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UdpClient::init_socket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes the socket according to the passed in options (if any). </p>

<p>Definition at line <a class="el" href="UdpClient_8cpp_source.html#l00046">46</a> of file <a class="el" href="UdpClient_8cpp_source.html">UdpClient.cpp</a>.</p>

<p>References <a class="el" href="Udp_8h_source.html#l00171">Udp::BUFFER_SIZE</a>, <a class="el" href="Udp_8h_source.html#l00198">Udp::do_not_route</a>, <a class="el" href="Logger_8h_source.html#l00071">Logger::error()</a>, <a class="el" href="Udp_8h_source.html#l00204">Udp::host</a>, <a class="el" href="Logger_8h_source.html#l00084">Logger::info()</a>, <a class="el" href="Udp_8cpp_source.html#l00158">Udp::log_options()</a>, <a class="el" href="Udp_8h_source.html#l00189">Udp::multicast</a>, <a class="el" href="Udp_8h_source.html#l00195">Udp::multicast_ttl</a>, <a class="el" href="Udp_8h_source.html#l00207">Udp::port</a>, <a class="el" href="Udp_8h_source.html#l00201">Udp::reuse_address</a>, <a class="el" href="UdpClient_8h_source.html#l00149">socket</a>, and <a class="el" href="Udp_8h_source.html#l00186">Udp::using_ipv6</a>.</p>

<p>Referenced by <a class="el" href="UdpClient_8cpp_source.html#l00200">resolve_handler()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="classLogger.html#a8c7d9b42b9a5480dceed15a21a2d57c6">Logger::info</a>(
            <span class="stringliteral">&quot;Initializing UDP client to host &#39;&quot;</span> + boost::lexical_cast&lt;string&gt;(<a class="code" href="classUdp.html#a798fd48815d9d97045e8e6a3a290d301">host</a>) + <span class="stringliteral">&quot;&#39; on port &quot;</span> + boost::lexical_cast&lt;string&gt;(<a class="code" href="classUdp.html#af69ea781b31a1fa62e5d3012b6288dc8">port</a>),
            <a class="code" href="classUdp.html#af69ea781b31a1fa62e5d3012b6288dc8">port</a>, <a class="code" href="classUdp.html#a798fd48815d9d97045e8e6a3a290d301">host</a>);
    <a class="code" href="classUdp.html#aa3def7bb682cc264bb2e425d93517e17">log_options</a>();

    <span class="keywordflow">if</span> (<a class="code" href="classUdp.html#a3522427333a9a3520e8c8a207cb1a6f2">using_ipv6</a> &amp;&amp; *<a class="code" href="classUdp.html#a3522427333a9a3520e8c8a207cb1a6f2">using_ipv6</a>)
        <a class="code" href="classUdpClient.html#a5e929af056033e7b1fd3f72ad2bd1849">socket</a>-&gt;open(udp::v6());
    <span class="keywordflow">else</span>
        <a class="code" href="classUdpClient.html#a5e929af056033e7b1fd3f72ad2bd1849">socket</a>-&gt;open(udp::v4());

    <span class="keywordflow">if</span> (!<a class="code" href="classUdpClient.html#a5e929af056033e7b1fd3f72ad2bd1849">socket</a>-&gt;is_open())
    {
        <span class="keywordtype">string</span> message(<span class="stringliteral">&quot;Failed to open UDP client socket&quot;</span>);
        <a class="code" href="classLogger.html#adb709be72ac3e448f2af97b9cafaef2f">Logger::error</a>(message, <a class="code" href="classUdp.html#af69ea781b31a1fa62e5d3012b6288dc8">port</a>, <a class="code" href="classUdp.html#a798fd48815d9d97045e8e6a3a290d301">host</a>);
        fire_error(message);
    }

    <span class="comment">// synchronize the buffer size of the socket with this class&#39;s buffer size</span>
    boost::asio::socket_base::receive_buffer_size buf_size_option(<a class="code" href="classUdp.html#aa72dc03ed420eee2098841f5998e3c53">BUFFER_SIZE</a>);
    <a class="code" href="classUdpClient.html#a5e929af056033e7b1fd3f72ad2bd1849">socket</a>-&gt;set_option(buf_size_option);

    <span class="comment">// set multicast ttl and out going interface</span>
    <span class="keywordflow">if</span> (<a class="code" href="classUdp.html#aff2511b739bdeee2875c07305b364042">multicast</a> &amp;&amp; *<a class="code" href="classUdp.html#aff2511b739bdeee2875c07305b364042">multicast</a>)
    {
        <span class="keywordflow">if</span> (<a class="code" href="classUdp.html#a11f39b2d209d628bdb52ff461e5898d2">multicast_ttl</a>)
        {
            boost::asio::ip::multicast::hops option(*<a class="code" href="classUdp.html#a11f39b2d209d628bdb52ff461e5898d2">multicast_ttl</a>);
            <a class="code" href="classUdpClient.html#a5e929af056033e7b1fd3f72ad2bd1849">socket</a>-&gt;set_option(option);
        }
    }

    <span class="keywordflow">if</span> (<a class="code" href="classUdp.html#ace1cbe1cd248a6ae689848f25c26d9d1">do_not_route</a>)
    {
        boost::asio::socket_base::do_not_route option(*<a class="code" href="classUdp.html#ace1cbe1cd248a6ae689848f25c26d9d1">do_not_route</a>);
        <a class="code" href="classUdpClient.html#a5e929af056033e7b1fd3f72ad2bd1849">socket</a>-&gt;set_option(option);
    }

    <span class="keywordflow">if</span> (<a class="code" href="classUdp.html#a7572159d5d08e4e85e8a1eeba37eb1b9">reuse_address</a>)
    {
        boost::asio::socket_base::reuse_address option(*<a class="code" href="classUdp.html#a7572159d5d08e4e85e8a1eeba37eb1b9">reuse_address</a>);
        <a class="code" href="classUdpClient.html#a5e929af056033e7b1fd3f72ad2bd1849">socket</a>-&gt;set_option(option);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae62759a7050f171fe12413ec658bb38b"></a><!-- doxytag: member="UdpClient::listen" ref="ae62759a7050f171fe12413ec658bb38b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UdpClient::listen </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [private, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Helper function that will listen for incoming data on the UDP connection for the client, specifically responses to data already sent. </p>

<p>Implements <a class="el" href="classUdp.html#a645a7a67007362e349cacc78f9870954">Udp</a>.</p>

<p>Definition at line <a class="el" href="UdpClient_8cpp_source.html#l00254">254</a> of file <a class="el" href="UdpClient_8cpp_source.html">UdpClient.cpp</a>.</p>

<p>References <a class="el" href="Udp_8h_source.html#l00204">Udp::host</a>, <a class="el" href="Udp_8h_source.html#l00207">Udp::port</a>, <a class="el" href="Udp_8h_source.html#l00174">Udp::receive_buffer</a>, <a class="el" href="Udp_8cpp_source.html#l00059">Udp::receive_handler()</a>, <a class="el" href="Udp_8h_source.html#l00210">Udp::remote_endpoint</a>, <a class="el" href="UdpClient_8h_source.html#l00149">socket</a>, and <a class="el" href="Logger_8h_source.html#l00097">Logger::warn()</a>.</p>

<p>Referenced by <a class="el" href="UdpClient_8cpp_source.html#l00137">send()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (<a class="code" href="classUdp.html#ae7fa8c26a933bf54f13f2230760a17e3">remote_endpoint</a> &amp;&amp; <a class="code" href="classUdp.html#ae7fa8c26a933bf54f13f2230760a17e3">remote_endpoint</a>.get())
        <a class="code" href="classUdpClient.html#a5e929af056033e7b1fd3f72ad2bd1849">socket</a>-&gt;async_receive_from(boost::asio::buffer(<a class="code" href="classUdp.html#a7f21cfeaaccb297124d7582607981afc">receive_buffer</a>), *<a class="code" href="classUdp.html#ae7fa8c26a933bf54f13f2230760a17e3">remote_endpoint</a>,
                boost::bind(&amp;<a class="code" href="classUdp.html#a1edcafcfd4202b3f9cc5a0724f26fe7a">UdpClient::receive_handler</a>, <span class="keyword">this</span>, _1, _2, <a class="code" href="classUdpClient.html#a5e929af056033e7b1fd3f72ad2bd1849">socket</a>, <a class="code" href="classUdp.html#ae7fa8c26a933bf54f13f2230760a17e3">remote_endpoint</a>, <a class="code" href="classUdp.html#a798fd48815d9d97045e8e6a3a290d301">host</a>, <a class="code" href="classUdp.html#af69ea781b31a1fa62e5d3012b6288dc8">port</a>));
    <span class="keywordflow">else</span>
        <a class="code" href="classLogger.html#ae0ebb73647360cb425de15cb9790563d">Logger::warn</a>(<span class="stringliteral">&quot;remote endpoint is null&quot;</span>, <a class="code" href="classUdp.html#af69ea781b31a1fa62e5d3012b6288dc8">port</a>, <a class="code" href="classUdp.html#a798fd48815d9d97045e8e6a3a290d301">host</a>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a16e67afc411590eb1602fc02e3395599"></a><!-- doxytag: member="UdpClient::resolve_handler" ref="a16e67afc411590eb1602fc02e3395599" args="(const boost::system::error_code &amp;err, udp::resolver::iterator endpoint_iterator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UdpClient::resolve_handler </td>
          <td>(</td>
          <td class="paramtype">const boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">udp::resolver::iterator&#160;</td>
          <td class="paramname"><em>endpoint_iterator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>I/O handler invoked when the remote host is resolved. This handler attempts to asynchronously establish a UDP connection with the remote host.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">err</td><td>The error code encountered when trying to receive data, if any occurred. On success, this value is zero, and nonzero on error. </td></tr>
    <tr><td class="paramname">endpoint_iterator</td><td>Allows the client to iterate through resolvers to retry the connection if it initially fails to connect. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="UdpClient_8cpp_source.html#l00200">200</a> of file <a class="el" href="UdpClient_8cpp_source.html">UdpClient.cpp</a>.</p>

<p>References <a class="el" href="Logger_8h_source.html#l00071">Logger::error()</a>, <a class="el" href="UdpClient_8cpp_source.html#l00238">flush()</a>, <a class="el" href="Udp_8h_source.html#l00204">Udp::host</a>, <a class="el" href="Logger_8h_source.html#l00084">Logger::info()</a>, <a class="el" href="UdpClient_8cpp_source.html#l00046">init_socket()</a>, <a class="el" href="Udp_8h_source.html#l00207">Udp::port</a>, <a class="el" href="Udp_8h_source.html#l00210">Udp::remote_endpoint</a>, <a class="el" href="UdpClient_8h_source.html#l00164">resolved_endpoint</a>, <a class="el" href="UdpClient_8h_source.html#l00144">resolver</a>, and <a class="el" href="UdpClient_8h_source.html#l00149">socket</a>.</p>

<p>Referenced by <a class="el" href="UdpClient_8cpp_source.html#l00137">send()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (err)
    {
        udp::resolver::iterator end;
        <span class="keywordflow">if</span> (endpoint_iterator != end &amp;&amp; err == boost::asio::error::host_not_found)
        {
            <span class="comment">// If we haven&#39;t tried resolving using all resolvers, try with another</span>
            udp::resolver::query query(<a class="code" href="classUdp.html#a798fd48815d9d97045e8e6a3a290d301">host</a>, boost::lexical_cast&lt;string&gt;(<a class="code" href="classUdp.html#af69ea781b31a1fa62e5d3012b6288dc8">port</a>));
            <a class="code" href="classUdpClient.html#a1ea233a699d5d1955bb3fa4bfca2ee2f">resolver</a>-&gt;async_resolve(query, boost::bind(&amp;<a class="code" href="classUdpClient.html#a16e67afc411590eb1602fc02e3395599">UdpClient::resolve_handler</a>, <span class="keyword">this</span>, _1, endpoint_iterator++));
        }
        <span class="keywordflow">else</span>
        { <span class="comment">// We have tried and cannot recover, fail permanently</span>
            <span class="keywordtype">string</span> message(<span class="stringliteral">&quot;Error: resolving host &quot;</span> + <a class="code" href="classUdp.html#a798fd48815d9d97045e8e6a3a290d301">host</a> + <span class="stringliteral">&quot;:&quot;</span> + boost::lexical_cast&lt;string&gt;(<a class="code" href="classUdp.html#af69ea781b31a1fa62e5d3012b6288dc8">port</a>) + <span class="stringliteral">&quot; error was &quot;</span> + err.message());

            <a class="code" href="classLogger.html#adb709be72ac3e448f2af97b9cafaef2f">Logger::error</a>(message, <a class="code" href="classUdp.html#af69ea781b31a1fa62e5d3012b6288dc8">port</a>, <a class="code" href="classUdp.html#a798fd48815d9d97045e8e6a3a290d301">host</a>);
            fire_error(message);

            <span class="keywordflow">return</span>;
        }
    }

    fire_resolve();

    <a class="code" href="classLogger.html#a8c7d9b42b9a5480dceed15a21a2d57c6">Logger::info</a>(<span class="stringliteral">&quot;udpclient: resolved, going to send&quot;</span>, <a class="code" href="classUdp.html#af69ea781b31a1fa62e5d3012b6288dc8">port</a>, <a class="code" href="classUdp.html#a798fd48815d9d97045e8e6a3a290d301">host</a>);

    <span class="comment">// We succeeded resolving the endpoint, continue</span>
    <a class="code" href="classUdp.html#ae7fa8c26a933bf54f13f2230760a17e3">remote_endpoint</a> = boost::make_shared&lt;udp::endpoint&gt;(*endpoint_iterator);

    <span class="keywordflow">if</span> (!<a class="code" href="classUdpClient.html#a5e929af056033e7b1fd3f72ad2bd1849">socket</a>-&gt;is_open())
        <a class="code" href="classUdpClient.html#a4c1f1672598ea18294f2486e071e0985">init_socket</a>();

    <span class="comment">// This endpoint has now been initialized</span>
    <a class="code" href="classUdpClient.html#a342b58425b4ccaf7de2a3ad8dcbc4df8">resolved_endpoint</a> = <span class="keyword">true</span>;

    <a class="code" href="classUdpClient.html#a755db78b027af8161b0b79563c857f2f">flush</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a86e50f32bbb7aaf657ea5cc91cbc99d2"></a><!-- doxytag: member="UdpClient::send" ref="a86e50f32bbb7aaf657ea5cc91cbc99d2" args="(const string &amp;data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UdpClient::send </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronously sends data to the remote host to which this client is connected.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to send across the wire </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classClient.html#ae02f1c7ffac49b7543244da28fbb58aa">Client</a>.</p>

<p>Definition at line <a class="el" href="UdpClient_8cpp_source.html#l00137">137</a> of file <a class="el" href="UdpClient_8cpp_source.html">UdpClient.cpp</a>.</p>

<p>References <a class="el" href="Logger_8h_source.html#l00071">Logger::error()</a>, <a class="el" href="Udp_8h_source.html#l00213">Udp::failed</a>, <a class="el" href="UdpClient_8cpp_source.html#l00238">flush()</a>, <a class="el" href="Udp_8h_source.html#l00204">Udp::host</a>, <a class="el" href="Logger_8h_source.html#l00084">Logger::info()</a>, <a class="el" href="UdpClient_8cpp_source.html#l00254">listen()</a>, <a class="el" href="UdpClient_8h_source.html#l00159">msgs_not_sent</a>, <a class="el" href="Udp_8h_source.html#l00177">Udp::pending_sends</a>, <a class="el" href="Udp_8h_source.html#l00180">Udp::pending_sends_mutex</a>, <a class="el" href="Udp_8h_source.html#l00207">Udp::port</a>, <a class="el" href="UdpClient_8h_source.html#l00154">queue_mtx</a>, <a class="el" href="Udp_8h_source.html#l00210">Udp::remote_endpoint</a>, <a class="el" href="UdpClient_8cpp_source.html#l00200">resolve_handler()</a>, <a class="el" href="UdpClient_8h_source.html#l00164">resolved_endpoint</a>, <a class="el" href="UdpClient_8h_source.html#l00144">resolver</a>, <a class="el" href="Udp_8cpp_source.html#l00016">Udp::send_handler()</a>, <a class="el" href="Udp_8h_source.html#l00183">Udp::should_close</a>, <a class="el" href="UdpClient_8h_source.html#l00149">socket</a>, and <a class="el" href="Udp_8h_source.html#l00186">Udp::using_ipv6</a>.</p>

<p>Referenced by <a class="el" href="UdpClient_8cpp_source.html#l00238">flush()</a>, and <a class="el" href="UdpClient_8cpp_source.html#l00125">send_bytes()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (<a class="code" href="classUdp.html#a91a6ea6959febc662830e818b89ed884">failed</a>)
    {
        <span class="comment">// Log &amp; fire an error</span>
        <span class="keywordtype">string</span> message(<span class="stringliteral">&quot;Trying to send from a UDP client that has permanently failed!&quot;</span>);
        <a class="code" href="classLogger.html#adb709be72ac3e448f2af97b9cafaef2f">Logger::error</a>(message, <a class="code" href="classUdp.html#af69ea781b31a1fa62e5d3012b6288dc8">port</a>, <a class="code" href="classUdp.html#a798fd48815d9d97045e8e6a3a290d301">host</a>);
        <span class="keywordflow">return</span>;
    }

    <span class="keywordflow">if</span> (<a class="code" href="classUdp.html#a01a27e2a1b252f39cefd61eb81a18220">should_close</a>)
        <span class="keywordflow">return</span>;

    <a class="code" href="classLogger.html#a8c7d9b42b9a5480dceed15a21a2d57c6">Logger::info</a>(<span class="stringliteral">&quot;udpclient: sending a msg of size: &quot;</span> + boost::lexical_cast&lt;std::string&gt;(msg.size()) + <span class="stringliteral">&quot; which is: &quot;</span> + msg, <a class="code" href="classUdp.html#af69ea781b31a1fa62e5d3012b6288dc8">port</a>, <a class="code" href="classUdp.html#a798fd48815d9d97045e8e6a3a290d301">host</a>);

    <a class="code" href="classUdp.html#af67ced15878e36d5dbfa433262876922">pending_sends_mutex</a>.lock();
    <a class="code" href="classUdp.html#ac4b9b234de6090250125a1ea05764014">pending_sends</a>++;
    <a class="code" href="classUdp.html#af67ced15878e36d5dbfa433262876922">pending_sends_mutex</a>.unlock();

    <span class="keywordflow">if</span> (!<a class="code" href="classUdpClient.html#a342b58425b4ccaf7de2a3ad8dcbc4df8">resolved_endpoint</a>)
    {
        <a class="code" href="classLogger.html#a8c7d9b42b9a5480dceed15a21a2d57c6">Logger::info</a>(<span class="stringliteral">&quot;udpclient: resolving &quot;</span> + <a class="code" href="classUdp.html#a798fd48815d9d97045e8e6a3a290d301">host</a> + <span class="stringliteral">&quot;:&quot;</span> + boost::lexical_cast&lt;string&gt;(<a class="code" href="classUdp.html#af69ea781b31a1fa62e5d3012b6288dc8">port</a>), <a class="code" href="classUdp.html#af69ea781b31a1fa62e5d3012b6288dc8">port</a>, <a class="code" href="classUdp.html#a798fd48815d9d97045e8e6a3a290d301">host</a>);

        <a class="code" href="classUdpClient.html#aa978126795bc551151f6442ba8421fc9">queue_mtx</a>.lock();
        <a class="code" href="classUdpClient.html#a8843ba58204e08e3250b483d459b3416">msgs_not_sent</a>.push(msg);
        <a class="code" href="classUdpClient.html#aa978126795bc551151f6442ba8421fc9">queue_mtx</a>.unlock();

        <span class="comment">// Create a query to resolve this host &amp; port</span>
        <span class="keywordflow">if</span> (<a class="code" href="classUdp.html#a3522427333a9a3520e8c8a207cb1a6f2">using_ipv6</a> &amp;&amp; *<a class="code" href="classUdp.html#a3522427333a9a3520e8c8a207cb1a6f2">using_ipv6</a>)
        {
            <span class="comment">// Asynchronously resolve the remote host, and once the host is resolved, create a connection</span>
            udp::resolver::query query(udp::v6(), <a class="code" href="classUdp.html#a798fd48815d9d97045e8e6a3a290d301">host</a>, boost::lexical_cast&lt;string&gt;(<a class="code" href="classUdp.html#af69ea781b31a1fa62e5d3012b6288dc8">port</a>),
                    boost::asio::ip::resolver_query_base::numeric_service);
            <a class="code" href="classUdpClient.html#a1ea233a699d5d1955bb3fa4bfca2ee2f">resolver</a>-&gt;async_resolve(query, boost::bind(&amp;<a class="code" href="classUdpClient.html#a16e67afc411590eb1602fc02e3395599">UdpClient::resolve_handler</a>, <span class="keyword">this</span>, _1, _2));
        }
        <span class="keywordflow">else</span>
        {
            <span class="comment">// Asynchronously resolve the remote host, and once the host is resolved, create a connection</span>
            udp::resolver::query query(udp::v4(), <a class="code" href="classUdp.html#a798fd48815d9d97045e8e6a3a290d301">host</a>, boost::lexical_cast&lt;string&gt;(<a class="code" href="classUdp.html#af69ea781b31a1fa62e5d3012b6288dc8">port</a>),
                    boost::asio::ip::resolver_query_base::numeric_service);
            <a class="code" href="classUdpClient.html#a1ea233a699d5d1955bb3fa4bfca2ee2f">resolver</a>-&gt;async_resolve(query, boost::bind(&amp;<a class="code" href="classUdpClient.html#a16e67afc411590eb1602fc02e3395599">UdpClient::resolve_handler</a>, <span class="keyword">this</span>, _1, _2));
        }
    }
    <span class="keywordflow">else</span>
    {
        <a class="code" href="classUdpClient.html#a755db78b027af8161b0b79563c857f2f">flush</a>(); <span class="comment">// any pending messages? send them.</span>

        <a class="code" href="classLogger.html#a8c7d9b42b9a5480dceed15a21a2d57c6">Logger::info</a>(<span class="stringliteral">&quot;udpclient: attempting to send &quot;</span> + boost::lexical_cast&lt;string&gt;(msg.size()) + <span class="stringliteral">&quot; bytes of data: &quot;</span> + msg, <a class="code" href="classUdp.html#af69ea781b31a1fa62e5d3012b6288dc8">port</a>, <a class="code" href="classUdp.html#a798fd48815d9d97045e8e6a3a290d301">host</a>);

        <span class="comment">// send the message</span>
        <span class="keywordflow">if</span> (<a class="code" href="classUdpClient.html#a5e929af056033e7b1fd3f72ad2bd1849">socket</a>-&gt;is_open() &amp;&amp; <a class="code" href="classUdp.html#ae7fa8c26a933bf54f13f2230760a17e3">remote_endpoint</a>.get())
        {
            <a class="code" href="classUdpClient.html#a5e929af056033e7b1fd3f72ad2bd1849">socket</a>-&gt;async_send_to(boost::asio::buffer(msg.data(), msg.size()), *<a class="code" href="classUdp.html#ae7fa8c26a933bf54f13f2230760a17e3">remote_endpoint</a>,
                    boost::bind(&amp;<a class="code" href="classUdp.html#a8c7b302089f5dd3979b5e1572b190ca8">UdpClient::send_handler</a>, <span class="keyword">this</span>, _1, _2, msg, <a class="code" href="classUdp.html#a798fd48815d9d97045e8e6a3a290d301">host</a>, <a class="code" href="classUdp.html#af69ea781b31a1fa62e5d3012b6288dc8">port</a>));

            <a class="code" href="classLogger.html#a8c7d9b42b9a5480dceed15a21a2d57c6">Logger::info</a>(<span class="stringliteral">&quot;udpclient: (async) send called&quot;</span>, <a class="code" href="classUdp.html#af69ea781b31a1fa62e5d3012b6288dc8">port</a>, <a class="code" href="classUdp.html#a798fd48815d9d97045e8e6a3a290d301">host</a>);

            <span class="keywordflow">if</span> (!<a class="code" href="classUdp.html#a01a27e2a1b252f39cefd61eb81a18220">should_close</a>)
                <a class="code" href="classUdpClient.html#ae62759a7050f171fe12413ec658bb38b">listen</a>(); <span class="comment">// listen for responses</span>
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad55f42a3c5cb3698b49975c8a065079e"></a><!-- doxytag: member="UdpClient::send_bytes" ref="ad55f42a3c5cb3698b49975c8a065079e" args="(const vector&lt; byte &gt; &amp;bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UdpClient::send_bytes </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="Event_8h.html#ae0aa21f6bcb621fe36c2c962aa0452fe">byte</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronously sends bytes to the remote host to which this client is connected.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>The data to send across the wire </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classClient.html#a6d77759bc7022e45a3e4326757bd6b8b">Client</a>.</p>

<p>Definition at line <a class="el" href="UdpClient_8cpp_source.html#l00125">125</a> of file <a class="el" href="UdpClient_8cpp_source.html">UdpClient.cpp</a>.</p>

<p>References <a class="el" href="UdpEvent_8h_source.html#l00088">UdpEvent::data</a>, and <a class="el" href="UdpClient_8cpp_source.html#l00137">send()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">string</span> data;

    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; bytes.size(); i++)
    {
        data.push_back((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>) bytes[i]);
    }

    <a class="code" href="classUdpClient.html#a86e50f32bbb7aaf657ea5cc91cbc99d2">send</a>(data);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a64b6b51f6a2316f7235381409f9cc327"></a><!-- doxytag: member="UdpClient::shutdown" ref="a64b6b51f6a2316f7235381409f9cc327" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UdpClient::shutdown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gracefully shutdown this UDP client, waiting until all sends have completed before freeing all resources for this UDP client and shutting down any open connections. This function is exposed the javascript API. </p>

<p>Implements <a class="el" href="classNetworkObject.html#a2f519457fd87c8a92cf265a2b2883e96">NetworkObject</a>.</p>

<p>Definition at line <a class="el" href="UdpClient_8cpp_source.html#l00107">107</a> of file <a class="el" href="UdpClient_8cpp_source.html">UdpClient.cpp</a>.</p>

<p>References <a class="el" href="UdpClient_8cpp_source.html#l00097">close()</a>, <a class="el" href="Udp_8h_source.html#l00213">Udp::failed</a>, <a class="el" href="Udp_8h_source.html#l00177">Udp::pending_sends</a>, <a class="el" href="Udp_8h_source.html#l00180">Udp::pending_sends_mutex</a>, and <a class="el" href="Udp_8h_source.html#l00183">Udp::should_close</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (!<a class="code" href="classUdp.html#a91a6ea6959febc662830e818b89ed884">failed</a>)
    {
        <a class="code" href="classUdp.html#a01a27e2a1b252f39cefd61eb81a18220">should_close</a> = <span class="keyword">true</span>;

        <a class="code" href="classUdp.html#af67ced15878e36d5dbfa433262876922">pending_sends_mutex</a>.lock();
        <span class="keywordtype">int</span> pending_sends_now = <a class="code" href="classUdp.html#ac4b9b234de6090250125a1ea05764014">pending_sends</a>;
        <a class="code" href="classUdp.html#af67ced15878e36d5dbfa433262876922">pending_sends_mutex</a>.unlock();

        <span class="keywordflow">if</span> (pending_sends_now == 0)
        {
            fire_close();
            <a class="code" href="classUdpClient.html#a48cc5f9ce547f5b0505fb8395ac93d32">close</a>();
        }
    }
}
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a8843ba58204e08e3250b483d459b3416"></a><!-- doxytag: member="UdpClient::msgs_not_sent" ref="a8843ba58204e08e3250b483d459b3416" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::queue&lt;string&gt; <a class="el" href="classUdpClient.html#a8843ba58204e08e3250b483d459b3416">UdpClient::msgs_not_sent</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Messages waiting to be sent, since the host hasn't been resolved yet. </p>

<p>Definition at line <a class="el" href="UdpClient_8h_source.html#l00159">159</a> of file <a class="el" href="UdpClient_8h_source.html">UdpClient.h</a>.</p>

<p>Referenced by <a class="el" href="UdpClient_8cpp_source.html#l00238">flush()</a>, and <a class="el" href="UdpClient_8cpp_source.html#l00137">send()</a>.</p>

</div>
</div>
<a class="anchor" id="aa978126795bc551151f6442ba8421fc9"></a><!-- doxytag: member="UdpClient::queue_mtx" ref="aa978126795bc551151f6442ba8421fc9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::mutex <a class="el" href="classUdpClient.html#aa978126795bc551151f6442ba8421fc9">UdpClient::queue_mtx</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Mutex for the message queue. </p>

<p>Definition at line <a class="el" href="UdpClient_8h_source.html#l00154">154</a> of file <a class="el" href="UdpClient_8h_source.html">UdpClient.h</a>.</p>

<p>Referenced by <a class="el" href="UdpClient_8cpp_source.html#l00238">flush()</a>, and <a class="el" href="UdpClient_8cpp_source.html#l00137">send()</a>.</p>

</div>
</div>
<a class="anchor" id="a342b58425b4ccaf7de2a3ad8dcbc4df8"></a><!-- doxytag: member="UdpClient::resolved_endpoint" ref="a342b58425b4ccaf7de2a3ad8dcbc4df8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classUdpClient.html#a342b58425b4ccaf7de2a3ad8dcbc4df8">UdpClient::resolved_endpoint</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A flag representing whether the remote host for this UDP client has already been resolved. </p>

<p>Definition at line <a class="el" href="UdpClient_8h_source.html#l00164">164</a> of file <a class="el" href="UdpClient_8h_source.html">UdpClient.h</a>.</p>

<p>Referenced by <a class="el" href="UdpClient_8cpp_source.html#l00200">resolve_handler()</a>, and <a class="el" href="UdpClient_8cpp_source.html#l00137">send()</a>.</p>

</div>
</div>
<a class="anchor" id="a1ea233a699d5d1955bb3fa4bfca2ee2f"></a><!-- doxytag: member="UdpClient::resolver" ref="a1ea233a699d5d1955bb3fa4bfca2ee2f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;udp::resolver&gt; <a class="el" href="classUdpClient.html#a1ea233a699d5d1955bb3fa4bfca2ee2f">UdpClient::resolver</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resolver object provided by <code>boost</code> to resolve the remote hostname and port </p>

<p>Definition at line <a class="el" href="UdpClient_8h_source.html#l00144">144</a> of file <a class="el" href="UdpClient_8h_source.html">UdpClient.h</a>.</p>

<p>Referenced by <a class="el" href="UdpClient_8cpp_source.html#l00200">resolve_handler()</a>, <a class="el" href="UdpClient_8cpp_source.html#l00137">send()</a>, and <a class="el" href="UdpClient_8cpp_source.html#l00016">UdpClient()</a>.</p>

</div>
</div>
<a class="anchor" id="a5e929af056033e7b1fd3f72ad2bd1849"></a><!-- doxytag: member="UdpClient::socket" ref="a5e929af056033e7b1fd3f72ad2bd1849" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;udp::socket&gt; <a class="el" href="classUdpClient.html#a5e929af056033e7b1fd3f72ad2bd1849">UdpClient::socket</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A shared reference to the socket used to connect to the remote host </p>

<p>Definition at line <a class="el" href="UdpClient_8h_source.html#l00149">149</a> of file <a class="el" href="UdpClient_8h_source.html">UdpClient.h</a>.</p>

<p>Referenced by <a class="el" href="UdpClient_8cpp_source.html#l00097">close()</a>, <a class="el" href="UdpClient_8cpp_source.html#l00046">init_socket()</a>, <a class="el" href="UdpClient_8cpp_source.html#l00254">listen()</a>, <a class="el" href="UdpClient_8cpp_source.html#l00200">resolve_handler()</a>, <a class="el" href="UdpClient_8cpp_source.html#l00137">send()</a>, and <a class="el" href="UdpClient_8cpp_source.html#l00016">UdpClient()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/jtedesco/dev/sockit/src/udp/<a class="el" href="UdpClient_8h_source.html">UdpClient.h</a></li>
<li>/home/jtedesco/dev/sockit/src/udp/<a class="el" href="UdpClient_8cpp_source.html">UdpClient.cpp</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Mon Aug 1 2011 16:37:53 for SockIt by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
