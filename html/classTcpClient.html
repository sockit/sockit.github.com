<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SockIt: TcpClient Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SockIt</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<h1>TcpClient Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="TcpClient" --><!-- doxytag: inherits="Tcp,Client" -->
<p><code>#include &lt;<a class="el" href="TcpClient_8h_source.html">TcpClient.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TcpClient:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classTcpClient.png" usemap="#TcpClient_map" alt=""/>
  <map id="TcpClient_map" name="TcpClient_map">
<area href="classTcp.html" alt="Tcp" shape="rect" coords="0,56,95,80"/>
<area href="classClient.html" alt="Client" shape="rect" coords="105,56,200,80"/>
<area href="classNetworkObject.html" alt="NetworkObject" shape="rect" coords="105,0,200,24"/>
</map>
 </div></div>

<p><a href="classTcpClient-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpClient.html#aa1e96bd9ed563f3eaf022cc4e90f91c2">TcpClient</a> (const string &amp;<a class="el" href="classTcp.html#a0e981d15f94a460b91845bce9b930c61">host</a>, int <a class="el" href="classTcp.html#a7ed15f78afc9d0675404b4b41cc723ba">port</a>, boost::asio::io_service &amp;<a class="el" href="classTcp.html#ad0c319a0974aa3f07e9c5ae290ea18b4">io_service</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpClient.html#a1d42085cbb76326fd3698e6924cfbe55">TcpClient</a> (const string &amp;<a class="el" href="classTcp.html#a0e981d15f94a460b91845bce9b930c61">host</a>, int <a class="el" href="classTcp.html#a7ed15f78afc9d0675404b4b41cc723ba">port</a>, boost::asio::io_service &amp;<a class="el" href="classTcp.html#ad0c319a0974aa3f07e9c5ae290ea18b4">io_service</a>, map&lt; string, string &gt; options)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpClient.html#a125d2277f401cbdebadb9689a5933e18">~TcpClient</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpClient.html#a139cffd600eaf851c3560d73a1ba3a54">send</a> (const string &amp;data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpClient.html#a1d749cbc2e255d8d3204dfd2d2c58d5f">send_bytes</a> (const vector&lt; <a class="el" href="Event_8h.html#ae0aa21f6bcb621fe36c2c962aa0452fe">byte</a> &gt; &amp;bytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpClient.html#a1f0ae8f7c7c12530bc481b77ed984790">shutdown</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpClient.html#a9caf99246bc1f36dcc69773077ddece8">get_port</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpClient.html#a4c1ecfdba951d559456c4066a73c8bf6">get_host</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpClient.html#a5275d221f99f3d9702841b461e36108c">FB_JSAPI_EVENT</a> (disconnect, 1,(const string &amp;))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpClient.html#a651d1d61f19169b5755e1716b159eeb8">FB_JSAPI_EVENT</a> (connect, 0,())</td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpClient.html#a03a3ef57b2df46a21e21640362457871">fire_error_event</a> (const string &amp;message)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpClient.html#a279302da46c29b24b539b4e7ddf20b94">fire_disconnect_event</a> (const string &amp;message)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpClient.html#a8085a788062b837c12040533a18aa933">fire_data_event</a> (const string data, boost::shared_ptr&lt; tcp::socket &gt; <a class="el" href="classTcpClient.html#add183a7de092c7c13ae6ab90766c9881">connection</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpClient.html#a1ee082bbca3927811bbe2c0aa75386c4">close</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpClient.html#a430902765fe325faf409fce8aa3374d2">TcpClient</a> (const <a class="el" href="classTcpClient.html">TcpClient</a> &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpClient.html#aeac8e51b95f1ced1141a02ac934bc46d">init</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpClient.html#a1f9f4dc2af0e396f2c3a46a1e47b68d7">init_socket</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpClient.html#a4bdf8c1ccee6d9cdb9a2220a95814f0e">resolve_handler</a> (const boost::system::error_code &amp;error_code, tcp::resolver::iterator endpoint_iterator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpClient.html#a95419f512dec781b141a4beeea05c9a5">connect_handler</a> (const boost::system::error_code &amp;error_code, tcp::resolver::iterator endpoint_iterator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpClient.html#a22407ce44587c805c32009fffe79a95f">listen</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpClient.html#a8272c8570d9f57b40230ff17b3a42156">flush</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; tcp::socket &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpClient.html#add183a7de092c7c13ae6ab90766c9881">connection</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; tcp::resolver &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpClient.html#af3244fcf0139e5a07bd7b85f3e7bb6c9">resolver</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpClient.html#aaceab0b8199fff1898b9c9301748733d">connected</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boost::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpClient.html#a96d0c8fe68ec52f42a1d287356027adb">connected_mutex</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">queue&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpClient.html#a1ed777da769d6f064d9f908adabf2284">data_queue</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boost::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpClient.html#a158c145cba5559a4e728772b044fbbb8">data_queue_mutex</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This class represents a TCP client, which inherits basic TCP handling functionality from <code><a class="el" href="classTcp.html">Tcp</a></code>, and defines additional functionality to resolve and connect to a remote host. </p>

<p>Definition at line <a class="el" href="TcpClient_8h_source.html#l00026">26</a> of file <a class="el" href="TcpClient_8h_source.html">TcpClient.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa1e96bd9ed563f3eaf022cc4e90f91c2"></a><!-- doxytag: member="TcpClient::TcpClient" ref="aa1e96bd9ed563f3eaf022cc4e90f91c2" args="(const string &amp;host, int port, boost::asio::io_service &amp;io_service)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TcpClient::TcpClient </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::asio::io_service &amp;&#160;</td>
          <td class="paramname"><em>io_service</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Builds a TCP client to connect to a specified remote host and port, and begins asynchronously resolving and connecting to the remote host, given an I/O service to asynchronously perform I/O requests.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>The hostname of the remote host to which this client will connect </td></tr>
    <tr><td class="paramname">port</td><td>The port of the remote host to which this client will connect </td></tr>
    <tr><td class="paramname">io_service</td><td>The I/O service to use to perform asynchronous I/O requests </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="TcpClient_8cpp_source.html#l00010">10</a> of file <a class="el" href="TcpClient_8cpp_source.html">TcpClient.cpp</a>.</p>

<p>References <a class="el" href="TcpClient_8h_source.html#l00186">connection</a>, <a class="el" href="Logger_8h_source.html#l00071">Logger::error()</a>, <a class="el" href="Tcp_8h_source.html#l00281">Tcp::failed</a>, <a class="el" href="TcpClient_8cpp_source.html#l00044">init()</a>, and <a class="el" href="TcpClient_8h_source.html#l00191">resolver</a>.</p>
<div class="fragment"><pre class="fragment">                                                                                    :
    <a class="code" href="classTcp.html#af081afa2fd34edc12ac0dda43851352c">Tcp</a>(<a class="code" href="classTcp.html#a0e981d15f94a460b91845bce9b930c61">host</a>, <a class="code" href="classTcp.html#a7ed15f78afc9d0675404b4b41cc723ba">port</a>, <a class="code" href="classTcp.html#ad0c319a0974aa3f07e9c5ae290ea18b4">io_service</a>), <a class="code" href="classTcpClient.html#af3244fcf0139e5a07bd7b85f3e7bb6c9">resolver</a>(<span class="keyword">new</span> tcp::resolver(<a class="code" href="classTcp.html#ad0c319a0974aa3f07e9c5ae290ea18b4">io_service</a>)), <a class="code" href="classTcpClient.html#add183a7de092c7c13ae6ab90766c9881">connection</a>(<span class="keyword">new</span> tcp::socket(<a class="code" href="classTcp.html#ad0c319a0974aa3f07e9c5ae290ea18b4">io_service</a>))
{
    <span class="comment">// Check that the connection and resolver are valid, and fail gracefully if they are not</span>
    <span class="keywordflow">if</span> (!<a class="code" href="classTcpClient.html#af3244fcf0139e5a07bd7b85f3e7bb6c9">resolver</a>.get() || !<a class="code" href="classTcpClient.html#add183a7de092c7c13ae6ab90766c9881">connection</a>.get())
    {
        <a class="code" href="classTcp.html#a9dbc59f5343aa045be1a888356ef6fbf">failed</a> = <span class="keyword">true</span>;
        <span class="keywordtype">string</span> message(<span class="stringliteral">&quot;Failed to initialize TCP client, failed to initialize properly&quot;</span>);
        <a class="code" href="classLogger.html#adb709be72ac3e448f2af97b9cafaef2f">Logger::error</a>(message, <a class="code" href="classTcp.html#a7ed15f78afc9d0675404b4b41cc723ba">port</a>, <a class="code" href="classTcp.html#a0e981d15f94a460b91845bce9b930c61">host</a>);
        fire_error(message);
        <span class="keywordflow">return</span>;
    }

    <a class="code" href="classTcpClient.html#aeac8e51b95f1ced1141a02ac934bc46d">init</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1d42085cbb76326fd3698e6924cfbe55"></a><!-- doxytag: member="TcpClient::TcpClient" ref="a1d42085cbb76326fd3698e6924cfbe55" args="(const string &amp;host, int port, boost::asio::io_service &amp;io_service, map&lt; string, string &gt; options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TcpClient::TcpClient </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::asio::io_service &amp;&#160;</td>
          <td class="paramname"><em>io_service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; string, string &gt;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Builds a TCP client to connect to a specified remote host and port, and begins asynchronously resolving and connecting to the remote host, given an I/O service to asynchronously perform I/O requests.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>The hostname of the remote host to which this client will connect </td></tr>
    <tr><td class="paramname">port</td><td>The port of the remote host to which this client will connect </td></tr>
    <tr><td class="paramname">io_service</td><td>The I/O service to use to perform asynchronous I/O requests </td></tr>
    <tr><td class="paramname">options</td><td>A map of options specifying the behavior of the socket </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="TcpClient_8cpp_source.html#l00026">26</a> of file <a class="el" href="TcpClient_8cpp_source.html">TcpClient.cpp</a>.</p>

<p>References <a class="el" href="TcpClient_8h_source.html#l00186">connection</a>, <a class="el" href="Logger_8h_source.html#l00071">Logger::error()</a>, <a class="el" href="Tcp_8h_source.html#l00281">Tcp::failed</a>, <a class="el" href="TcpClient_8cpp_source.html#l00044">init()</a>, <a class="el" href="Tcp_8cpp_source.html#l00197">Tcp::parse_args()</a>, and <a class="el" href="TcpClient_8h_source.html#l00191">resolver</a>.</p>
<div class="fragment"><pre class="fragment">                                                                                                                 :
    <a class="code" href="classTcp.html#af081afa2fd34edc12ac0dda43851352c">Tcp</a>(<a class="code" href="classTcp.html#a0e981d15f94a460b91845bce9b930c61">host</a>, <a class="code" href="classTcp.html#a7ed15f78afc9d0675404b4b41cc723ba">port</a>, <a class="code" href="classTcp.html#ad0c319a0974aa3f07e9c5ae290ea18b4">io_service</a>), <a class="code" href="classTcpClient.html#af3244fcf0139e5a07bd7b85f3e7bb6c9">resolver</a>(<span class="keyword">new</span> tcp::resolver(<a class="code" href="classTcp.html#ad0c319a0974aa3f07e9c5ae290ea18b4">io_service</a>)), <a class="code" href="classTcpClient.html#add183a7de092c7c13ae6ab90766c9881">connection</a>(<span class="keyword">new</span> tcp::socket(<a class="code" href="classTcp.html#ad0c319a0974aa3f07e9c5ae290ea18b4">io_service</a>))
{
    <span class="comment">// Check that the connection and resolver are valid, and fail gracefully if they are not</span>
    <span class="keywordflow">if</span> (!<a class="code" href="classTcpClient.html#af3244fcf0139e5a07bd7b85f3e7bb6c9">resolver</a>.get() || !<a class="code" href="classTcpClient.html#add183a7de092c7c13ae6ab90766c9881">connection</a>.get())
    {
        <a class="code" href="classTcp.html#a9dbc59f5343aa045be1a888356ef6fbf">failed</a> = <span class="keyword">true</span>;
        <span class="keywordtype">string</span> message(<span class="stringliteral">&quot;Failed to initialize TCP client, failed to initialize properly&quot;</span>);
        <a class="code" href="classLogger.html#adb709be72ac3e448f2af97b9cafaef2f">Logger::error</a>(message, <a class="code" href="classTcp.html#a7ed15f78afc9d0675404b4b41cc723ba">port</a>, <a class="code" href="classTcp.html#a0e981d15f94a460b91845bce9b930c61">host</a>);
        fire_error(message);
        <span class="keywordflow">return</span>;
    }

    <a class="code" href="classTcp.html#a65753a8c2d9bad07216abdcd5a8a1e86">parse_args</a>(options);

    <a class="code" href="classTcpClient.html#aeac8e51b95f1ced1141a02ac934bc46d">init</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a125d2277f401cbdebadb9689a5933e18"></a><!-- doxytag: member="TcpClient::~TcpClient" ref="a125d2277f401cbdebadb9689a5933e18" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TcpClient::~TcpClient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deconstructs a TCP client, immediately calling <code>close</code> to shutdown this client's socket and stop listening for responses. </p>

<p>Definition at line <a class="el" href="TcpClient_8cpp_source.html#l00114">114</a> of file <a class="el" href="TcpClient_8cpp_source.html">TcpClient.cpp</a>.</p>

<p>References <a class="el" href="TcpClient_8cpp_source.html#l00119">close()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="classTcpClient.html#a1ee082bbca3927811bbe2c0aa75386c4">close</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a430902765fe325faf409fce8aa3374d2"></a><!-- doxytag: member="TcpClient::TcpClient" ref="a430902765fe325faf409fce8aa3374d2" args="(const TcpClient &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TcpClient::TcpClient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTcpClient.html">TcpClient</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disallows copying a TCP client </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a1ee082bbca3927811bbe2c0aa75386c4"></a><!-- doxytag: member="TcpClient::close" ref="a1ee082bbca3927811bbe2c0aa75386c4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TcpClient::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Immediately cancels any pending operations and closes this client's socket. </p>

<p>Implements <a class="el" href="classTcp.html#a48b0192669ab99dc953ab3feae5c1b1c">Tcp</a>.</p>

<p>Definition at line <a class="el" href="TcpClient_8cpp_source.html#l00119">119</a> of file <a class="el" href="TcpClient_8cpp_source.html">TcpClient.cpp</a>.</p>

<p>References <a class="el" href="TcpClient_8h_source.html#l00186">connection</a>, <a class="el" href="Tcp_8h_source.html#l00264">Tcp::host</a>, <a class="el" href="Tcp_8h_source.html#l00269">Tcp::port</a>, <a class="el" href="TcpClient_8h_source.html#l00191">resolver</a>, <a class="el" href="Tcp_8h_source.html#l00224">Tcp::waiting_to_shutdown</a>, and <a class="el" href="Logger_8h_source.html#l00097">Logger::warn()</a>.</p>

<p>Referenced by <a class="el" href="TcpClient_8cpp_source.html#l00144">shutdown()</a>, and <a class="el" href="TcpClient_8cpp_source.html#l00114">~TcpClient()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="classTcp.html#a96b0558a6ce522708bfd06cf1e6e45ba">waiting_to_shutdown</a> = <span class="keyword">true</span>;
    <a class="code" href="classTcpClient.html#af3244fcf0139e5a07bd7b85f3e7bb6c9">resolver</a>-&gt;cancel();

    <span class="comment">// Shutdown the IO service, cancel any transfers on the socket, and close the socket</span>
    <span class="keywordflow">if</span> (<a class="code" href="classTcpClient.html#add183a7de092c7c13ae6ab90766c9881">connection</a>-&gt;is_open())
    {
        <span class="keywordflow">try</span>
        {
            <a class="code" href="classTcpClient.html#add183a7de092c7c13ae6ab90766c9881">connection</a>-&gt;shutdown(<a class="code" href="classTcpClient.html#add183a7de092c7c13ae6ab90766c9881">connection</a>-&gt;shutdown_both);
        }
        <span class="keywordflow">catch</span> (...)
        {
            <a class="code" href="classLogger.html#ae0ebb73647360cb425de15cb9790563d">Logger::warn</a>(<span class="stringliteral">&quot;Socket shutdown improperly, proceeding anyway&quot;</span>, <a class="code" href="classTcp.html#a7ed15f78afc9d0675404b4b41cc723ba">port</a>, <a class="code" href="classTcp.html#a0e981d15f94a460b91845bce9b930c61">host</a>);
        }

        <a class="code" href="classTcpClient.html#add183a7de092c7c13ae6ab90766c9881">connection</a>-&gt;close();
    }
    <span class="keywordflow">else</span>
    {
        <a class="code" href="classLogger.html#ae0ebb73647360cb425de15cb9790563d">Logger::warn</a>(<span class="stringliteral">&quot;Failed to cleanly shutdown TCP client connection, continuing anyways&quot;</span>, <a class="code" href="classTcp.html#a7ed15f78afc9d0675404b4b41cc723ba">port</a>, <a class="code" href="classTcp.html#a0e981d15f94a460b91845bce9b930c61">host</a>);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a95419f512dec781b141a4beeea05c9a5"></a><!-- doxytag: member="TcpClient::connect_handler" ref="a95419f512dec781b141a4beeea05c9a5" args="(const boost::system::error_code &amp;error_code, tcp::resolver::iterator endpoint_iterator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TcpClient::connect_handler </td>
          <td>(</td>
          <td class="paramtype">const boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>error_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tcp::resolver::iterator&#160;</td>
          <td class="paramname"><em>endpoint_iterator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>I/O handler invoked when this client has attempted to connect to its remote host. If the connection failed, this handler will reattempt the connection by using another resolver if possible, and otherwise fail permanently.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">error_code</td><td>The error code encountered when trying to receive data, if any occurred. On success, this value is zero, and nonzero on error. </td></tr>
    <tr><td class="paramname">endpoint_iterator</td><td>Allows the client to iterate through resolvers to retry the connection if it initially fails to connect. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="TcpClient_8cpp_source.html#l00278">278</a> of file <a class="el" href="TcpClient_8cpp_source.html">TcpClient.cpp</a>.</p>

<p>References <a class="el" href="TcpClient_8h_source.html#l00197">connected</a>, <a class="el" href="TcpClient_8h_source.html#l00202">connected_mutex</a>, <a class="el" href="TcpClient_8h_source.html#l00186">connection</a>, <a class="el" href="Tcp_8h_source.html#l00276">Tcp::disconnect_errors</a>, <a class="el" href="Logger_8h_source.html#l00071">Logger::error()</a>, <a class="el" href="TcpClient_8cpp_source.html#l00338">flush()</a>, <a class="el" href="Tcp_8h_source.html#l00264">Tcp::host</a>, <a class="el" href="Logger_8h_source.html#l00084">Logger::info()</a>, <a class="el" href="Tcp_8h_source.html#l00269">Tcp::port</a>, <a class="el" href="Tcp_8h_source.html#l00214">Tcp::receive_buffer</a>, <a class="el" href="Tcp_8cpp_source.html#l00088">Tcp::receive_handler()</a>, <a class="el" href="TcpClient_8cpp_source.html#l00215">resolve_handler()</a>, <a class="el" href="TcpClient_8h_source.html#l00191">resolver</a>, and <a class="el" href="Logger_8h_source.html#l00097">Logger::warn()</a>.</p>

<p>Referenced by <a class="el" href="TcpClient_8cpp_source.html#l00215">resolve_handler()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// If there was an error to connect, log the error and abort connection</span>
    <span class="keywordflow">if</span> (error_code)
    {
        <span class="comment">// Check for disconnection errors</span>
        std::set&lt;boost::system::error_code&gt;::iterator find_result = <a class="code" href="classTcp.html#adcbc3e86d98f8ba37247674cf67f77fd">disconnect_errors</a>.find(error_code);
        <span class="keywordflow">if</span> (find_result != <a class="code" href="classTcp.html#adcbc3e86d98f8ba37247674cf67f77fd">disconnect_errors</a>.end())
        {
            <span class="keywordflow">if</span> (error_code == boost::asio::error::operation_aborted)
            {
                <a class="code" href="classLogger.html#ae0ebb73647360cb425de15cb9790563d">Logger::warn</a>(<span class="stringliteral">&quot;TCP connect was aborted&quot;</span>);
                <span class="keywordflow">return</span>;
            }
            <span class="keywordflow">else</span>
            {
                <span class="keywordtype">string</span> message(<span class="stringliteral">&quot;TCP connect failed, disconnected: &#39;&quot;</span> + error_code.message() + <span class="stringliteral">&quot;&#39;&quot;</span>);
                <a class="code" href="classLogger.html#ae0ebb73647360cb425de15cb9790563d">Logger::warn</a>(message, <a class="code" href="classTcp.html#a7ed15f78afc9d0675404b4b41cc723ba">port</a>, <a class="code" href="classTcp.html#a0e981d15f94a460b91845bce9b930c61">host</a>);
                fire_disconnect(message);
                <span class="keywordflow">return</span>;
            }
        }

        <span class="comment">// Check if this was not the last possible connection in the iterator</span>
        tcp::resolver::iterator end;
        <span class="keywordflow">if</span> (endpoint_iterator != end &amp;&amp; error_code == boost::asio::error::host_not_found)
        {
            <span class="comment">// Create a query to resolve this host &amp; port</span>
            tcp::resolver::query query(<a class="code" href="classTcp.html#a0e981d15f94a460b91845bce9b930c61">host</a>, boost::lexical_cast&lt;string&gt;(<a class="code" href="classTcp.html#a7ed15f78afc9d0675404b4b41cc723ba">port</a>));

            <span class="comment">// Try the next possible endpoint</span>
            <a class="code" href="classTcpClient.html#af3244fcf0139e5a07bd7b85f3e7bb6c9">resolver</a>-&gt;async_resolve(query, boost::bind(&amp;<a class="code" href="classTcpClient.html#a4bdf8c1ccee6d9cdb9a2220a95814f0e">TcpClient::resolve_handler</a>, <span class="keyword">this</span>, _1, endpoint_iterator++));
        }
        <span class="keywordflow">else</span>
        {
            <span class="comment">// If we&#39;ve tried every possible endpoint, fail permanently</span>
            <span class="keywordtype">string</span> message(<span class="stringliteral">&quot;Failed to connect to host, with message: &#39;&quot;</span> + error_code.message() + <span class="stringliteral">&quot;&#39;&quot;</span>);
            <a class="code" href="classLogger.html#adb709be72ac3e448f2af97b9cafaef2f">Logger::error</a>(message, <a class="code" href="classTcp.html#a7ed15f78afc9d0675404b4b41cc723ba">port</a>, <a class="code" href="classTcp.html#a0e981d15f94a460b91845bce9b930c61">host</a>);
            fire_error(message);
            <span class="keywordflow">return</span>;
        }
    }

    <span class="comment">// Log success, and record that we are now connected</span>
    <a class="code" href="classLogger.html#a8c7d9b42b9a5480dceed15a21a2d57c6">Logger::info</a>(<span class="stringliteral">&quot;Connection established to host&quot;</span>, <a class="code" href="classTcp.html#a7ed15f78afc9d0675404b4b41cc723ba">port</a>, <a class="code" href="classTcp.html#a0e981d15f94a460b91845bce9b930c61">host</a>);
    fire_connect();

    <span class="comment">// Start receiving data on this connection</span>
    <a class="code" href="classTcpClient.html#add183a7de092c7c13ae6ab90766c9881">connection</a>-&gt;async_receive(boost::asio::buffer(<a class="code" href="classTcp.html#aeb630e95d24f26852437098df5896b16">receive_buffer</a>),
            boost::bind(&amp;<a class="code" href="classTcp.html#a96707e496b0fcef660c3f22fb6efc0fd">TcpClient::receive_handler</a>, <span class="keyword">this</span>, _1, _2, <a class="code" href="classTcpClient.html#add183a7de092c7c13ae6ab90766c9881">connection</a>, <a class="code" href="classTcp.html#a0e981d15f94a460b91845bce9b930c61">host</a>, <a class="code" href="classTcp.html#a7ed15f78afc9d0675404b4b41cc723ba">port</a>));

    <span class="comment">// Flush data from the queue if necessary</span>
    <a class="code" href="classTcpClient.html#a8272c8570d9f57b40230ff17b3a42156">flush</a>();

    <a class="code" href="classTcpClient.html#a96d0c8fe68ec52f42a1d287356027adb">connected_mutex</a>.lock();

    <a class="code" href="classTcpClient.html#aaceab0b8199fff1898b9c9301748733d">connected</a> = <span class="keyword">true</span>;
    <a class="code" href="classTcpClient.html#a96d0c8fe68ec52f42a1d287356027adb">connected_mutex</a>.unlock();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5275d221f99f3d9702841b461e36108c"></a><!-- doxytag: member="TcpClient::FB_JSAPI_EVENT" ref="a5275d221f99f3d9702841b461e36108c" args="(disconnect, 1,(const string &amp;))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TcpClient::FB_JSAPI_EVENT </td>
          <td>(</td>
          <td class="paramtype">disconnect&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">(const string &amp;)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The javascript event fired on a disconnect-type network error. This is fired on the following <code>boost</code> errors: </p>
<ul>
<li>
<code>boost::asio::error::connection_reset</code> </li>
<li>
<code>boost::asio::error::eof</code> </li>
<li>
<code>boost::asio::error::connection_aborted</code> </li>
<li>
<code>boost::asio::error::operation_aborted</code> </li>
</ul>

</div>
</div>
<a class="anchor" id="a651d1d61f19169b5755e1716b159eeb8"></a><!-- doxytag: member="TcpClient::FB_JSAPI_EVENT" ref="a651d1d61f19169b5755e1716b159eeb8" args="(connect, 0,())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TcpClient::FB_JSAPI_EVENT </td>
          <td>(</td>
          <td class="paramtype">connect&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">()&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The javascript event fired once a client has connected to its remote endpoint, or once a server has accepted a connection successfully (but has not yet receieved data), in this class, the former. </p>

</div>
</div>
<a class="anchor" id="a8085a788062b837c12040533a18aa933"></a><!-- doxytag: member="TcpClient::fire_data_event" ref="a8085a788062b837c12040533a18aa933" args="(const string data, boost::shared_ptr&lt; tcp::socket &gt; connection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TcpClient::fire_data_event </td>
          <td>(</td>
          <td class="paramtype">const string&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; tcp::socket &gt;&#160;</td>
          <td class="paramname"><em>connection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Helper to fire data event to javascript.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data received </td></tr>
    <tr><td class="paramname">connection</td><td>The connection on which to reply to the data </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classTcp.html#a7e5cfd764f04ca5e2729924b9d537db2">Tcp</a>.</p>

<p>Definition at line <a class="el" href="TcpClient_8cpp_source.html#l00378">378</a> of file <a class="el" href="TcpClient_8cpp_source.html">TcpClient.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    fire_data(boost::make_shared&lt;TcpEvent&gt;(<span class="keyword">this</span>, <a class="code" href="classTcpClient.html#add183a7de092c7c13ae6ab90766c9881">connection</a>, data));
}
</pre></div>
</div>
</div>
<a class="anchor" id="a279302da46c29b24b539b4e7ddf20b94"></a><!-- doxytag: member="TcpClient::fire_disconnect_event" ref="a279302da46c29b24b539b4e7ddf20b94" args="(const string &amp;message)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TcpClient::fire_disconnect_event </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Helper to fire an disconnect error event to javascript.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The error message </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classTcp.html#a69d92d55403e877f252bbfbfd7c02ec2">Tcp</a>.</p>

<p>Definition at line <a class="el" href="TcpClient_8cpp_source.html#l00373">373</a> of file <a class="el" href="TcpClient_8cpp_source.html">TcpClient.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    fire_disconnect(message);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a03a3ef57b2df46a21e21640362457871"></a><!-- doxytag: member="TcpClient::fire_error_event" ref="a03a3ef57b2df46a21e21640362457871" args="(const string &amp;message)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TcpClient::fire_error_event </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Helper to fire an error event to javascript.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The error message </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classTcp.html#a9798750750bc775de9a16d0f148bc002">Tcp</a>.</p>

<p>Definition at line <a class="el" href="TcpClient_8cpp_source.html#l00368">368</a> of file <a class="el" href="TcpClient_8cpp_source.html">TcpClient.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    fire_error(message);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8272c8570d9f57b40230ff17b3a42156"></a><!-- doxytag: member="TcpClient::flush" ref="a8272c8570d9f57b40230ff17b3a42156" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TcpClient::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Helper function to flush the queue of data if sends are requested before the client is connected </p>

<p>Definition at line <a class="el" href="TcpClient_8cpp_source.html#l00338">338</a> of file <a class="el" href="TcpClient_8cpp_source.html">TcpClient.cpp</a>.</p>

<p>References <a class="el" href="TcpClient_8h_source.html#l00186">connection</a>, <a class="el" href="TcpEvent_8h_source.html#l00090">TcpEvent::data</a>, <a class="el" href="TcpClient_8h_source.html#l00207">data_queue</a>, <a class="el" href="TcpClient_8h_source.html#l00212">data_queue_mutex</a>, <a class="el" href="Tcp_8h_source.html#l00264">Tcp::host</a>, <a class="el" href="Tcp_8h_source.html#l00269">Tcp::port</a>, and <a class="el" href="Tcp_8cpp_source.html#l00020">Tcp::send_handler()</a>.</p>

<p>Referenced by <a class="el" href="TcpClient_8cpp_source.html#l00278">connect_handler()</a>, and <a class="el" href="TcpClient_8cpp_source.html#l00177">send()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="classTcpClient.html#a158c145cba5559a4e728772b044fbbb8">data_queue_mutex</a>.lock();
    <span class="keywordflow">while</span> (!<a class="code" href="classTcpClient.html#a1ed777da769d6f064d9f908adabf2284">data_queue</a>.empty())
    {
        <a class="code" href="classTcpClient.html#a158c145cba5559a4e728772b044fbbb8">data_queue_mutex</a>.unlock();

        <span class="comment">// Pull the next data chunk to be sent off the queue</span>
        <a class="code" href="classTcpClient.html#a158c145cba5559a4e728772b044fbbb8">data_queue_mutex</a>.lock();
        <span class="keywordtype">string</span> data = <a class="code" href="classTcpClient.html#a1ed777da769d6f064d9f908adabf2284">data_queue</a>.front();
        <a class="code" href="classTcpClient.html#a1ed777da769d6f064d9f908adabf2284">data_queue</a>.pop();
        <a class="code" href="classTcpClient.html#a158c145cba5559a4e728772b044fbbb8">data_queue_mutex</a>.unlock();

        <span class="comment">// Asynchronously send the data across the connection</span>
        <a class="code" href="classTcpClient.html#add183a7de092c7c13ae6ab90766c9881">connection</a>-&gt;async_send(boost::asio::buffer(data.data(), data.size()),
                boost::bind(&amp;<a class="code" href="classTcp.html#a447cf3ccc28a073a6b871dd1f597c28d">TcpClient::send_handler</a>, <span class="keyword">this</span>, _1, _2, data, <a class="code" href="classTcp.html#a0e981d15f94a460b91845bce9b930c61">host</a>, <a class="code" href="classTcp.html#a7ed15f78afc9d0675404b4b41cc723ba">port</a>, <a class="code" href="classTcpClient.html#add183a7de092c7c13ae6ab90766c9881">connection</a>));
    }
    <a class="code" href="classTcpClient.html#a158c145cba5559a4e728772b044fbbb8">data_queue_mutex</a>.unlock();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4c1ecfdba951d559456c4066a73c8bf6"></a><!-- doxytag: member="TcpClient::get_host" ref="a4c1ecfdba951d559456c4066a73c8bf6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string TcpClient::get_host </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the host to which this client connects </p>

<p>Implements <a class="el" href="classClient.html#a01e5ea1bae012b2a46e8abd6b0bab704">Client</a>.</p>

<p>Definition at line <a class="el" href="TcpClient_8cpp_source.html#l00363">363</a> of file <a class="el" href="TcpClient_8cpp_source.html">TcpClient.cpp</a>.</p>

<p>References <a class="el" href="Tcp_8h_source.html#l00264">Tcp::host</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> <a class="code" href="classTcp.html#a0e981d15f94a460b91845bce9b930c61">host</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9caf99246bc1f36dcc69773077ddece8"></a><!-- doxytag: member="TcpClient::get_port" ref="a9caf99246bc1f36dcc69773077ddece8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TcpClient::get_port </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the port of the remote host on which this client connects </p>

<p>Implements <a class="el" href="classClient.html#ac9e4f13eef6b9a776b2bb6cca9d4f78b">Client</a>.</p>

<p>Definition at line <a class="el" href="TcpClient_8cpp_source.html#l00358">358</a> of file <a class="el" href="TcpClient_8cpp_source.html">TcpClient.cpp</a>.</p>

<p>References <a class="el" href="Tcp_8h_source.html#l00269">Tcp::port</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> <a class="code" href="classTcp.html#a7ed15f78afc9d0675404b4b41cc723ba">port</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aeac8e51b95f1ced1141a02ac934bc46d"></a><!-- doxytag: member="TcpClient::init" ref="aeac8e51b95f1ced1141a02ac934bc46d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TcpClient::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Helper function to initialize this client </p>

<p>Definition at line <a class="el" href="TcpClient_8cpp_source.html#l00044">44</a> of file <a class="el" href="TcpClient_8cpp_source.html">TcpClient.cpp</a>.</p>

<p>References <a class="el" href="TcpClient_8h_source.html#l00197">connected</a>, <a class="el" href="Logger_8h_source.html#l00071">Logger::error()</a>, <a class="el" href="Tcp_8h_source.html#l00281">Tcp::failed</a>, <a class="el" href="Tcp_8h_source.html#l00264">Tcp::host</a>, <a class="el" href="Logger_8h_source.html#l00084">Logger::info()</a>, <a class="el" href="Tcp_8cpp_source.html#l00229">Tcp::log_options()</a>, <a class="el" href="Tcp_8h_source.html#l00269">Tcp::port</a>, <a class="el" href="TcpClient_8cpp_source.html#l00215">resolve_handler()</a>, <a class="el" href="TcpClient_8h_source.html#l00191">resolver</a>, and <a class="el" href="Tcp_8h_source.html#l00229">Tcp::using_ipv6</a>.</p>

<p>Referenced by <a class="el" href="TcpClient_8cpp_source.html#l00010">TcpClient()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="classTcpClient.html#aaceab0b8199fff1898b9c9301748733d">connected</a> = <span class="keyword">false</span>;

    <a class="code" href="classLogger.html#a8c7d9b42b9a5480dceed15a21a2d57c6">Logger::info</a>(
            <span class="stringliteral">&quot;Initializing TCP client to host &#39;&quot;</span> + boost::lexical_cast&lt;string&gt;(<a class="code" href="classTcp.html#a0e981d15f94a460b91845bce9b930c61">host</a>) + <span class="stringliteral">&quot;&#39; on port &quot;</span> + boost::lexical_cast&lt;string&gt;(<a class="code" href="classTcp.html#a7ed15f78afc9d0675404b4b41cc723ba">port</a>),
            <a class="code" href="classTcp.html#a7ed15f78afc9d0675404b4b41cc723ba">port</a>, <a class="code" href="classTcp.html#a0e981d15f94a460b91845bce9b930c61">host</a>);
    <a class="code" href="classTcp.html#a59aee046563f221c89ab4b56146fcdc7">log_options</a>();
    <a class="code" href="classLogger.html#a8c7d9b42b9a5480dceed15a21a2d57c6">Logger::info</a>(
            <span class="stringliteral">&quot;Trying to resolve DNS information for host &quot;</span> + boost::lexical_cast&lt;string&gt;(<a class="code" href="classTcp.html#a0e981d15f94a460b91845bce9b930c61">host</a>) + <span class="stringliteral">&quot;&#39;, port &quot;</span> + boost::lexical_cast&lt;string&gt;(
                    <a class="code" href="classTcp.html#a7ed15f78afc9d0675404b4b41cc723ba">port</a>), <a class="code" href="classTcp.html#a7ed15f78afc9d0675404b4b41cc723ba">port</a>, <a class="code" href="classTcp.html#a0e981d15f94a460b91845bce9b930c61">host</a>);

    <span class="comment">// Create a query to resolve this host &amp; port</span>
    <span class="keywordflow">if</span> (<a class="code" href="classTcp.html#a395b2458742a84d78c1107ac8b59a7a8">using_ipv6</a> &amp;&amp; *<a class="code" href="classTcp.html#a395b2458742a84d78c1107ac8b59a7a8">using_ipv6</a>)
    {
        <span class="comment">// Asynchronously resolve the remote host, and once the host is resolved, create a connection</span>
        tcp::resolver::query query(tcp::v6(), <a class="code" href="classTcp.html#a0e981d15f94a460b91845bce9b930c61">host</a>, boost::lexical_cast&lt;string&gt;(<a class="code" href="classTcp.html#a7ed15f78afc9d0675404b4b41cc723ba">port</a>),
                boost::asio::ip::resolver_query_base::numeric_service);
        <span class="keywordflow">if</span> (<a class="code" href="classTcpClient.html#af3244fcf0139e5a07bd7b85f3e7bb6c9">resolver</a>.get())
            <a class="code" href="classTcpClient.html#af3244fcf0139e5a07bd7b85f3e7bb6c9">resolver</a>-&gt;async_resolve(query, boost::bind(&amp;<a class="code" href="classTcpClient.html#a4bdf8c1ccee6d9cdb9a2220a95814f0e">TcpClient::resolve_handler</a>, <span class="keyword">this</span>, _1, _2));
        <span class="keywordflow">else</span>
        {
            <a class="code" href="classTcp.html#a9dbc59f5343aa045be1a888356ef6fbf">failed</a> = <span class="keyword">true</span>;
            <span class="keywordtype">string</span> message(<span class="stringliteral">&quot;TCP client failed to resolve, invalid resolver&quot;</span>);
            <a class="code" href="classLogger.html#adb709be72ac3e448f2af97b9cafaef2f">Logger::error</a>(message, <a class="code" href="classTcp.html#a7ed15f78afc9d0675404b4b41cc723ba">port</a>, <a class="code" href="classTcp.html#a0e981d15f94a460b91845bce9b930c61">host</a>);
            fire_error(message);
        }
    }
    <span class="keywordflow">else</span>
    {
        <span class="comment">// Asynchronously resolve the remote host, and once the host is resolved, create a connection</span>
        tcp::resolver::query query(tcp::v4(), <a class="code" href="classTcp.html#a0e981d15f94a460b91845bce9b930c61">host</a>, boost::lexical_cast&lt;string&gt;(<a class="code" href="classTcp.html#a7ed15f78afc9d0675404b4b41cc723ba">port</a>),
                boost::asio::ip::resolver_query_base::numeric_service);
        <span class="keywordflow">if</span> (<a class="code" href="classTcpClient.html#af3244fcf0139e5a07bd7b85f3e7bb6c9">resolver</a>.get())
            <a class="code" href="classTcpClient.html#af3244fcf0139e5a07bd7b85f3e7bb6c9">resolver</a>-&gt;async_resolve(query, boost::bind(&amp;<a class="code" href="classTcpClient.html#a4bdf8c1ccee6d9cdb9a2220a95814f0e">TcpClient::resolve_handler</a>, <span class="keyword">this</span>, _1, _2));
        <span class="keywordflow">else</span>
        {
            <a class="code" href="classTcp.html#a9dbc59f5343aa045be1a888356ef6fbf">failed</a> = <span class="keyword">true</span>;
            <span class="keywordtype">string</span> message(<span class="stringliteral">&quot;TCP client failed to resolve, invalid resolver&quot;</span>);
            <a class="code" href="classLogger.html#adb709be72ac3e448f2af97b9cafaef2f">Logger::error</a>(message, <a class="code" href="classTcp.html#a7ed15f78afc9d0675404b4b41cc723ba">port</a>, <a class="code" href="classTcp.html#a0e981d15f94a460b91845bce9b930c61">host</a>);
            fire_error(message);
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1f9f4dc2af0e396f2c3a46a1e47b68d7"></a><!-- doxytag: member="TcpClient::init_socket" ref="a1f9f4dc2af0e396f2c3a46a1e47b68d7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TcpClient::init_socket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the properties of this socket </p>

<p>Definition at line <a class="el" href="TcpClient_8cpp_source.html#l00089">89</a> of file <a class="el" href="TcpClient_8cpp_source.html">TcpClient.cpp</a>.</p>

<p>References <a class="el" href="TcpClient_8h_source.html#l00186">connection</a>, <a class="el" href="Tcp_8h_source.html#l00239">Tcp::do_not_route</a>, <a class="el" href="Tcp_8h_source.html#l00244">Tcp::keep_alive</a>, <a class="el" href="Tcp_8h_source.html#l00249">Tcp::keep_alive_timeout</a>, <a class="el" href="Tcp_8h_source.html#l00234">Tcp::no_delay</a>, and <a class="el" href="Tcp_8cpp_source.html#l00243">Tcp::set_tcp_keepalive()</a>.</p>

<p>Referenced by <a class="el" href="TcpClient_8cpp_source.html#l00215">resolve_handler()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// Set the socket options for this client&#39;s TCP socket</span>
    <span class="keywordflow">if</span> (<a class="code" href="classTcp.html#a6bff7fed84126b745930da36030c68c7">do_not_route</a>)
    {
        boost::asio::socket_base::do_not_route option(*<a class="code" href="classTcp.html#a6bff7fed84126b745930da36030c68c7">do_not_route</a>);
        <a class="code" href="classTcpClient.html#add183a7de092c7c13ae6ab90766c9881">connection</a>-&gt;set_option(option);
    }
    <span class="keywordflow">if</span> (<a class="code" href="classTcp.html#a5cec5af76ec94551f8dc5f98639e9953">keep_alive</a>)
    {
        boost::asio::socket_base::keep_alive option(*<a class="code" href="classTcp.html#a5cec5af76ec94551f8dc5f98639e9953">keep_alive</a>);
        <a class="code" href="classTcpClient.html#add183a7de092c7c13ae6ab90766c9881">connection</a>-&gt;set_option(option);
    }
    <span class="keywordflow">if</span> (<a class="code" href="classTcp.html#a00a788b6d5b91b31b340f942617b9dda">no_delay</a>)
    {
        boost::asio::ip::tcp::no_delay option(*<a class="code" href="classTcp.html#a00a788b6d5b91b31b340f942617b9dda">no_delay</a>);
        <a class="code" href="classTcpClient.html#add183a7de092c7c13ae6ab90766c9881">connection</a>-&gt;set_option(option);
    }
    <span class="keywordflow">if</span> (<a class="code" href="classTcp.html#a08e171f501f01c117f5a3c04d394d137">keep_alive_timeout</a>)
    {
        <span class="comment">// Set the TCP keep-alive timeout - ignores return value</span>
        <a class="code" href="classTcp.html#aea9e4a82b08f1893900dad21a1fedfb7">set_tcp_keepalive</a>(<a class="code" href="classTcpClient.html#add183a7de092c7c13ae6ab90766c9881">connection</a>);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a22407ce44587c805c32009fffe79a95f"></a><!-- doxytag: member="TcpClient::listen" ref="a22407ce44587c805c32009fffe79a95f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TcpClient::listen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Helper function that will listen for incoming data on the TCP connection for the client, specifically responses to data already sent. </p>

</div>
</div>
<a class="anchor" id="a4bdf8c1ccee6d9cdb9a2220a95814f0e"></a><!-- doxytag: member="TcpClient::resolve_handler" ref="a4bdf8c1ccee6d9cdb9a2220a95814f0e" args="(const boost::system::error_code &amp;error_code, tcp::resolver::iterator endpoint_iterator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TcpClient::resolve_handler </td>
          <td>(</td>
          <td class="paramtype">const boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>error_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tcp::resolver::iterator&#160;</td>
          <td class="paramname"><em>endpoint_iterator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>I/O handler invoked when the remote host is resolved. This handler attempts to asynchronously establish a TCP connection with the remote host.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">error_code</td><td>The error code encountered when trying to receive data, if any occurred. On success, this value is zero, and nonzero on error. </td></tr>
    <tr><td class="paramname">endpoint_iterator</td><td>Allows the client to iterate through resolvers to retry the connection if it initially fails to connect. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="TcpClient_8cpp_source.html#l00215">215</a> of file <a class="el" href="TcpClient_8cpp_source.html">TcpClient.cpp</a>.</p>

<p>References <a class="el" href="TcpClient_8cpp_source.html#l00278">connect_handler()</a>, <a class="el" href="TcpClient_8h_source.html#l00186">connection</a>, <a class="el" href="Tcp_8h_source.html#l00276">Tcp::disconnect_errors</a>, <a class="el" href="Logger_8h_source.html#l00071">Logger::error()</a>, <a class="el" href="Tcp_8h_source.html#l00281">Tcp::failed</a>, <a class="el" href="Tcp_8h_source.html#l00264">Tcp::host</a>, <a class="el" href="Logger_8h_source.html#l00084">Logger::info()</a>, <a class="el" href="TcpClient_8cpp_source.html#l00089">init_socket()</a>, <a class="el" href="Tcp_8h_source.html#l00269">Tcp::port</a>, <a class="el" href="Tcp_8h_source.html#l00229">Tcp::using_ipv6</a>, and <a class="el" href="Logger_8h_source.html#l00097">Logger::warn()</a>.</p>

<p>Referenced by <a class="el" href="TcpClient_8cpp_source.html#l00278">connect_handler()</a>, and <a class="el" href="TcpClient_8cpp_source.html#l00044">init()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// If we encountered an error</span>
    <span class="keywordflow">if</span> (error_code)
    {
        <span class="comment">// Check for disconnection errors</span>
        std::set&lt;boost::system::error_code&gt;::iterator find_result = <a class="code" href="classTcp.html#adcbc3e86d98f8ba37247674cf67f77fd">disconnect_errors</a>.find(error_code);
        <span class="keywordflow">if</span> (find_result != <a class="code" href="classTcp.html#adcbc3e86d98f8ba37247674cf67f77fd">disconnect_errors</a>.end())
        {
            <span class="keywordflow">if</span> (error_code == boost::asio::error::operation_aborted)
            {
                <a class="code" href="classLogger.html#ae0ebb73647360cb425de15cb9790563d">Logger::warn</a>(<span class="stringliteral">&quot;TCP resolve was aborted&quot;</span>);
                <span class="keywordflow">return</span>;
            }
            <span class="keywordflow">else</span>
            {
                <span class="keywordtype">string</span> message(<span class="stringliteral">&quot;TCP resolve failed, disconnected: &#39;&quot;</span> + error_code.message() + <span class="stringliteral">&quot;&#39;&quot;</span>);
                <a class="code" href="classLogger.html#ae0ebb73647360cb425de15cb9790563d">Logger::warn</a>(message, <a class="code" href="classTcp.html#a7ed15f78afc9d0675404b4b41cc723ba">port</a>, <a class="code" href="classTcp.html#a0e981d15f94a460b91845bce9b930c61">host</a>);
                fire_disconnect(message);
                <span class="keywordflow">return</span>;
            }
        }

        <span class="comment">// We failed permanently, fail permanently and log it</span>
        <span class="keywordtype">string</span> message(<span class="stringliteral">&quot;Failed to resolve host with error: &quot;</span> + error_code.message());
        <a class="code" href="classLogger.html#adb709be72ac3e448f2af97b9cafaef2f">Logger::error</a>(message, <a class="code" href="classTcp.html#a7ed15f78afc9d0675404b4b41cc723ba">port</a>, <a class="code" href="classTcp.html#a0e981d15f94a460b91845bce9b930c61">host</a>);
        fire_error(message);
        <span class="keywordflow">return</span>;
    }

    <span class="keywordflow">if</span> (<a class="code" href="classTcpClient.html#add183a7de092c7c13ae6ab90766c9881">connection</a>.get())
    {
        <span class="comment">// Attempt to connect to the endpoint, using IPv6 if specified</span>
        tcp::endpoint receiver_endpoint = *endpoint_iterator;
        <span class="keywordflow">if</span> (<a class="code" href="classTcp.html#a395b2458742a84d78c1107ac8b59a7a8">using_ipv6</a> &amp;&amp; *<a class="code" href="classTcp.html#a395b2458742a84d78c1107ac8b59a7a8">using_ipv6</a>)
        {
            <a class="code" href="classTcpClient.html#add183a7de092c7c13ae6ab90766c9881">connection</a>-&gt;open(tcp::v6());
        }
        <span class="keywordflow">else</span>
        {
            <a class="code" href="classTcpClient.html#add183a7de092c7c13ae6ab90766c9881">connection</a>-&gt;open(tcp::v4());
        }

        <span class="comment">// Initialize the socket if it&#39;s open</span>
        <span class="keywordflow">if</span> (!<a class="code" href="classTcpClient.html#add183a7de092c7c13ae6ab90766c9881">connection</a>-&gt;is_open())
            <a class="code" href="classTcpClient.html#a1f9f4dc2af0e396f2c3a46a1e47b68d7">init_socket</a>();

        <span class="comment">// Log success</span>
        <a class="code" href="classLogger.html#a8c7d9b42b9a5480dceed15a21a2d57c6">Logger::info</a>(<span class="stringliteral">&quot;Host has been resolved, attempting to connect to host&quot;</span>, <a class="code" href="classTcp.html#a7ed15f78afc9d0675404b4b41cc723ba">port</a>, <a class="code" href="classTcp.html#a0e981d15f94a460b91845bce9b930c61">host</a>);
        fire_resolve();

        <span class="comment">// Try to asynchronously establish a connection to the host</span>
        <a class="code" href="classTcpClient.html#add183a7de092c7c13ae6ab90766c9881">connection</a>-&gt;async_connect(receiver_endpoint, boost::bind(&amp;<a class="code" href="classTcpClient.html#a95419f512dec781b141a4beeea05c9a5">TcpClient::connect_handler</a>, <span class="keyword">this</span>, _1, endpoint_iterator));
    }
    <span class="keywordflow">else</span>
    {
        <a class="code" href="classTcp.html#a9dbc59f5343aa045be1a888356ef6fbf">failed</a> = <span class="keyword">true</span>;
        <span class="keywordtype">string</span> message(<span class="stringliteral">&quot;TCP client failed to resolve, invalid connection&quot;</span>);
        <a class="code" href="classLogger.html#adb709be72ac3e448f2af97b9cafaef2f">Logger::error</a>(message, <a class="code" href="classTcp.html#a7ed15f78afc9d0675404b4b41cc723ba">port</a>, <a class="code" href="classTcp.html#a0e981d15f94a460b91845bce9b930c61">host</a>);
        fire_error(message);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a139cffd600eaf851c3560d73a1ba3a54"></a><!-- doxytag: member="TcpClient::send" ref="a139cffd600eaf851c3560d73a1ba3a54" args="(const string &amp;data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TcpClient::send </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronously sends data to the remote host to which this client is connected.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to send across the wire </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classClient.html#ae02f1c7ffac49b7543244da28fbb58aa">Client</a>.</p>

<p>Definition at line <a class="el" href="TcpClient_8cpp_source.html#l00177">177</a> of file <a class="el" href="TcpClient_8cpp_source.html">TcpClient.cpp</a>.</p>

<p>References <a class="el" href="Tcp_8h_source.html#l00254">Tcp::active_jobs</a>, <a class="el" href="Tcp_8h_source.html#l00259">Tcp::active_jobs_mutex</a>, <a class="el" href="TcpClient_8h_source.html#l00197">connected</a>, <a class="el" href="TcpClient_8h_source.html#l00202">connected_mutex</a>, <a class="el" href="TcpClient_8h_source.html#l00186">connection</a>, <a class="el" href="TcpClient_8h_source.html#l00207">data_queue</a>, <a class="el" href="TcpClient_8h_source.html#l00212">data_queue_mutex</a>, <a class="el" href="Logger_8h_source.html#l00071">Logger::error()</a>, <a class="el" href="Tcp_8h_source.html#l00281">Tcp::failed</a>, <a class="el" href="TcpClient_8cpp_source.html#l00338">flush()</a>, <a class="el" href="Tcp_8h_source.html#l00264">Tcp::host</a>, <a class="el" href="Tcp_8h_source.html#l00269">Tcp::port</a>, and <a class="el" href="Tcp_8cpp_source.html#l00020">Tcp::send_handler()</a>.</p>

<p>Referenced by <a class="el" href="TcpClient_8cpp_source.html#l00165">send_bytes()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (<a class="code" href="classTcp.html#a9dbc59f5343aa045be1a888356ef6fbf">failed</a>)
    {
        <span class="comment">// Log &amp; fire an error</span>
        <span class="keywordtype">string</span> message(<span class="stringliteral">&quot;Trying to send data on a TCP client that has permanently failed!&quot;</span>);
        <a class="code" href="classLogger.html#adb709be72ac3e448f2af97b9cafaef2f">Logger::error</a>(message, <a class="code" href="classTcp.html#a7ed15f78afc9d0675404b4b41cc723ba">port</a>, <a class="code" href="classTcp.html#a0e981d15f94a460b91845bce9b930c61">host</a>);
        <span class="keywordflow">return</span>;
    }

    <span class="comment">// If we&#39;re not already connected, then queue this data to be send</span>
    <a class="code" href="classTcpClient.html#a96d0c8fe68ec52f42a1d287356027adb">connected_mutex</a>.lock();
    <span class="keywordtype">bool</span> connected_now = <a class="code" href="classTcpClient.html#aaceab0b8199fff1898b9c9301748733d">connected</a>;
    <a class="code" href="classTcpClient.html#a96d0c8fe68ec52f42a1d287356027adb">connected_mutex</a>.unlock();

    <span class="keywordflow">if</span> (!connected_now)
    {
        <a class="code" href="classTcp.html#adcd27ee2753e2c0c43f58efa882a3ab5">active_jobs_mutex</a>.lock();
        <a class="code" href="classTcp.html#a4811b96fe77f74f10b14aac532036708">active_jobs</a>++;
        <a class="code" href="classTcp.html#adcd27ee2753e2c0c43f58efa882a3ab5">active_jobs_mutex</a>.unlock();
        <a class="code" href="classTcpClient.html#a158c145cba5559a4e728772b044fbbb8">data_queue_mutex</a>.lock();
        <a class="code" href="classTcpClient.html#a1ed777da769d6f064d9f908adabf2284">data_queue</a>.push(data);
        <a class="code" href="classTcpClient.html#a158c145cba5559a4e728772b044fbbb8">data_queue_mutex</a>.unlock();
    }
    <span class="keywordflow">else</span>
    {
        <span class="comment">// Check if the queue needs to be flushed, and if so, flush it</span>
        <a class="code" href="classTcpClient.html#a8272c8570d9f57b40230ff17b3a42156">flush</a>();

        <span class="comment">// Send the data, and record that we&#39;ve started a new send job</span>
        <a class="code" href="classTcp.html#adcd27ee2753e2c0c43f58efa882a3ab5">active_jobs_mutex</a>.lock();
        <a class="code" href="classTcp.html#a4811b96fe77f74f10b14aac532036708">active_jobs</a>++;
        <a class="code" href="classTcp.html#adcd27ee2753e2c0c43f58efa882a3ab5">active_jobs_mutex</a>.unlock();
        <a class="code" href="classTcpClient.html#add183a7de092c7c13ae6ab90766c9881">connection</a>-&gt;async_send(boost::asio::buffer(data.data(), data.size()),
                boost::bind(&amp;<a class="code" href="classTcp.html#a447cf3ccc28a073a6b871dd1f597c28d">TcpClient::send_handler</a>, <span class="keyword">this</span>, _1, _2, data, <a class="code" href="classTcp.html#a0e981d15f94a460b91845bce9b930c61">host</a>, <a class="code" href="classTcp.html#a7ed15f78afc9d0675404b4b41cc723ba">port</a>, <a class="code" href="classTcpClient.html#add183a7de092c7c13ae6ab90766c9881">connection</a>));
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1d749cbc2e255d8d3204dfd2d2c58d5f"></a><!-- doxytag: member="TcpClient::send_bytes" ref="a1d749cbc2e255d8d3204dfd2d2c58d5f" args="(const vector&lt; byte &gt; &amp;bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TcpClient::send_bytes </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="Event_8h.html#ae0aa21f6bcb621fe36c2c962aa0452fe">byte</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronously sends bytes to the remote host to which this client is connected.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>The bytes of data to send across the wire </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classClient.html#a6d77759bc7022e45a3e4326757bd6b8b">Client</a>.</p>

<p>Definition at line <a class="el" href="TcpClient_8cpp_source.html#l00165">165</a> of file <a class="el" href="TcpClient_8cpp_source.html">TcpClient.cpp</a>.</p>

<p>References <a class="el" href="TcpEvent_8h_source.html#l00090">TcpEvent::data</a>, and <a class="el" href="TcpClient_8cpp_source.html#l00177">send()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">string</span> data;

    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; bytes.size(); i++)
    {
        data.push_back((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>) bytes[i]);
    }

    <a class="code" href="classTcpClient.html#a139cffd600eaf851c3560d73a1ba3a54">send</a>(data);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1f0ae8f7c7c12530bc481b77ed984790"></a><!-- doxytag: member="TcpClient::shutdown" ref="a1f0ae8f7c7c12530bc481b77ed984790" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TcpClient::shutdown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gracefully shutdown this TCP client, waiting until all sends have completed before freeing all resources for this TCP client and shutting down any open connections. This function is exposed the javascript API. </p>

<p>Implements <a class="el" href="classNetworkObject.html#a2f519457fd87c8a92cf265a2b2883e96">NetworkObject</a>.</p>

<p>Definition at line <a class="el" href="TcpClient_8cpp_source.html#l00144">144</a> of file <a class="el" href="TcpClient_8cpp_source.html">TcpClient.cpp</a>.</p>

<p>References <a class="el" href="Tcp_8h_source.html#l00254">Tcp::active_jobs</a>, <a class="el" href="Tcp_8h_source.html#l00259">Tcp::active_jobs_mutex</a>, <a class="el" href="TcpClient_8cpp_source.html#l00119">close()</a>, <a class="el" href="Logger_8h_source.html#l00071">Logger::error()</a>, <a class="el" href="Tcp_8h_source.html#l00281">Tcp::failed</a>, <a class="el" href="Tcp_8h_source.html#l00264">Tcp::host</a>, <a class="el" href="Tcp_8h_source.html#l00269">Tcp::port</a>, and <a class="el" href="Tcp_8h_source.html#l00224">Tcp::waiting_to_shutdown</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (!<a class="code" href="classTcp.html#a9dbc59f5343aa045be1a888356ef6fbf">failed</a>)
    {
        <a class="code" href="classTcp.html#adcd27ee2753e2c0c43f58efa882a3ab5">active_jobs_mutex</a>.lock();
        <span class="keywordtype">int</span> current_jobs = <a class="code" href="classTcp.html#a4811b96fe77f74f10b14aac532036708">active_jobs</a>;
        <a class="code" href="classTcp.html#adcd27ee2753e2c0c43f58efa882a3ab5">active_jobs_mutex</a>.unlock();
        <a class="code" href="classTcp.html#a96b0558a6ce522708bfd06cf1e6e45ba">waiting_to_shutdown</a> = <span class="keyword">true</span>;
        <span class="keywordflow">if</span> (current_jobs == 0)
        {
            fire_close();
            <a class="code" href="classTcpClient.html#a1ee082bbca3927811bbe2c0aa75386c4">close</a>();
        }
    }
    <span class="keywordflow">else</span>
    {
        <span class="comment">// Log &amp; fire an error</span>
        <a class="code" href="classLogger.html#adb709be72ac3e448f2af97b9cafaef2f">Logger::error</a>(<span class="stringliteral">&quot;Trying to start the server listening, but the server has permanently failed!&quot;</span>, <a class="code" href="classTcp.html#a7ed15f78afc9d0675404b4b41cc723ba">port</a>, <a class="code" href="classTcp.html#a0e981d15f94a460b91845bce9b930c61">host</a>);
    }
}
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="aaceab0b8199fff1898b9c9301748733d"></a><!-- doxytag: member="TcpClient::connected" ref="aaceab0b8199fff1898b9c9301748733d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classTcpClient.html#aaceab0b8199fff1898b9c9301748733d">TcpClient::connected</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A flag recording whether this client is connected yet or not, used to queue send requests made before this client is connected if necessary. </p>

<p>Definition at line <a class="el" href="TcpClient_8h_source.html#l00197">197</a> of file <a class="el" href="TcpClient_8h_source.html">TcpClient.h</a>.</p>

<p>Referenced by <a class="el" href="TcpClient_8cpp_source.html#l00278">connect_handler()</a>, <a class="el" href="TcpClient_8cpp_source.html#l00044">init()</a>, and <a class="el" href="TcpClient_8cpp_source.html#l00177">send()</a>.</p>

</div>
</div>
<a class="anchor" id="a96d0c8fe68ec52f42a1d287356027adb"></a><!-- doxytag: member="TcpClient::connected_mutex" ref="a96d0c8fe68ec52f42a1d287356027adb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::mutex <a class="el" href="classTcpClient.html#a96d0c8fe68ec52f42a1d287356027adb">TcpClient::connected_mutex</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A mutex used to access the queue for pending jobs </p>

<p>Definition at line <a class="el" href="TcpClient_8h_source.html#l00202">202</a> of file <a class="el" href="TcpClient_8h_source.html">TcpClient.h</a>.</p>

<p>Referenced by <a class="el" href="TcpClient_8cpp_source.html#l00278">connect_handler()</a>, and <a class="el" href="TcpClient_8cpp_source.html#l00177">send()</a>.</p>

</div>
</div>
<a class="anchor" id="add183a7de092c7c13ae6ab90766c9881"></a><!-- doxytag: member="TcpClient::connection" ref="add183a7de092c7c13ae6ab90766c9881" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;tcp::socket&gt; <a class="el" href="classTcpClient.html#add183a7de092c7c13ae6ab90766c9881">TcpClient::connection</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A shared reference to the socket used to connect to the remote host </p>

<p>Definition at line <a class="el" href="TcpClient_8h_source.html#l00186">186</a> of file <a class="el" href="TcpClient_8h_source.html">TcpClient.h</a>.</p>

<p>Referenced by <a class="el" href="TcpClient_8cpp_source.html#l00119">close()</a>, <a class="el" href="TcpClient_8cpp_source.html#l00278">connect_handler()</a>, <a class="el" href="TcpClient_8cpp_source.html#l00338">flush()</a>, <a class="el" href="TcpClient_8cpp_source.html#l00089">init_socket()</a>, <a class="el" href="TcpClient_8cpp_source.html#l00215">resolve_handler()</a>, <a class="el" href="TcpClient_8cpp_source.html#l00177">send()</a>, and <a class="el" href="TcpClient_8cpp_source.html#l00010">TcpClient()</a>.</p>

</div>
</div>
<a class="anchor" id="a1ed777da769d6f064d9f908adabf2284"></a><!-- doxytag: member="TcpClient::data_queue" ref="a1ed777da769d6f064d9f908adabf2284" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">queue&lt;string&gt; <a class="el" href="classTcpClient.html#a1ed777da769d6f064d9f908adabf2284">TcpClient::data_queue</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A queue of data to be sent, which fills as 'send' or 'send_bytes' commands occur before the client is connected </p>

<p>Definition at line <a class="el" href="TcpClient_8h_source.html#l00207">207</a> of file <a class="el" href="TcpClient_8h_source.html">TcpClient.h</a>.</p>

<p>Referenced by <a class="el" href="TcpClient_8cpp_source.html#l00338">flush()</a>, and <a class="el" href="TcpClient_8cpp_source.html#l00177">send()</a>.</p>

</div>
</div>
<a class="anchor" id="a158c145cba5559a4e728772b044fbbb8"></a><!-- doxytag: member="TcpClient::data_queue_mutex" ref="a158c145cba5559a4e728772b044fbbb8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::mutex <a class="el" href="classTcpClient.html#a158c145cba5559a4e728772b044fbbb8">TcpClient::data_queue_mutex</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A mutex used to access the queue for pending jobs </p>

<p>Definition at line <a class="el" href="TcpClient_8h_source.html#l00212">212</a> of file <a class="el" href="TcpClient_8h_source.html">TcpClient.h</a>.</p>

<p>Referenced by <a class="el" href="TcpClient_8cpp_source.html#l00338">flush()</a>, and <a class="el" href="TcpClient_8cpp_source.html#l00177">send()</a>.</p>

</div>
</div>
<a class="anchor" id="af3244fcf0139e5a07bd7b85f3e7bb6c9"></a><!-- doxytag: member="TcpClient::resolver" ref="af3244fcf0139e5a07bd7b85f3e7bb6c9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;tcp::resolver&gt; <a class="el" href="classTcpClient.html#af3244fcf0139e5a07bd7b85f3e7bb6c9">TcpClient::resolver</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resolver object provided by <code>boost</code> to resolve the remote hostname and port </p>

<p>Definition at line <a class="el" href="TcpClient_8h_source.html#l00191">191</a> of file <a class="el" href="TcpClient_8h_source.html">TcpClient.h</a>.</p>

<p>Referenced by <a class="el" href="TcpClient_8cpp_source.html#l00119">close()</a>, <a class="el" href="TcpClient_8cpp_source.html#l00278">connect_handler()</a>, <a class="el" href="TcpClient_8cpp_source.html#l00044">init()</a>, and <a class="el" href="TcpClient_8cpp_source.html#l00010">TcpClient()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/jtedesco/dev/sockit/src/tcp/<a class="el" href="TcpClient_8h_source.html">TcpClient.h</a></li>
<li>/home/jtedesco/dev/sockit/src/tcp/<a class="el" href="TcpClient_8cpp_source.html">TcpClient.cpp</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Mon Aug 1 2011 16:37:52 for SockIt by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
